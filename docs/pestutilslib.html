<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pypestutils.pestutilslib API documentation</title>
<meta name="description" content="Mid-level pestutilslib module to implement ctypes functions." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pypestutils.pestutilslib</code></h1>
</header>
<section id="section-intro">
<p>Mid-level pestutilslib module to implement ctypes functions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Mid-level pestutilslib module to implement ctypes functions.&#34;&#34;&#34;
from __future__ import annotations

import logging
from ctypes import byref, c_char, c_double, c_int, create_string_buffer
from os import PathLike
from pathlib import Path

import numpy as np
import numpy.typing as npt

from . import enum
from .data import ManyArrays, validate_scalar


class PestUtilsLibError(BaseException):
    &#34;&#34;&#34;Exception from PestUtilsLib.&#34;&#34;&#34;

    pass


class PestUtilsLib:
    &#34;&#34;&#34;Mid-level Fortran-Python handler for pestutils library via ctypes.

    Parameters
    ----------
    logger_level : int, str, default 20 (INFO)
    &#34;&#34;&#34;

    def __init__(self, *, logger_level=logging.INFO) -&gt; None:
        from .ctypes_declarations import prototype
        from .finder import load
        from .logger import get_logger

        self.logger = get_logger(self.__class__.__name__, logger_level)
        self.pestutils = load()
        self.logger.debug(&#34;loaded %s&#34;, self.pestutils)
        prototype(self.pestutils)
        self.logger.debug(&#34;added prototypes&#34;)

    # def __del__(self):
    #    &#34;&#34;&#34;Clean-up library instance.&#34;&#34;&#34;
    #    try:
    #        self.free_all_memory()
    #    except (AttributeError, PestUtilsLibError) as err:
    #        if hasattr(self, &#34;logger&#34;):
    #            self.logger.warning(&#34;cannot call __del__: %s&#34;, err)

    def create_char_array(self, init: str | bytes, name: str):
        &#34;&#34;&#34;Create c_char Array with a fixed size from dimvar and intial value.

        Parameters
        ----------
        init : str or bytes
            Initial value.
        name : str
            Uppercase variable length name, e.g. LENFILENAME or LENVARTYPE.
        &#34;&#34;&#34;
        from .ctypes_declarations import get_dimvar_int

        if isinstance(init, str):
            init = init.encode()
        elif isinstance(init, bytes):
            pass
        else:
            raise TypeError(f&#34;expecting either str or bytes; found {type(init)}&#34;)
        size = get_dimvar_int(self.pestutils, name)
        if len(init) &gt; size:
            raise ValueError(f&#34;init size is {len(init)} but {name} is {size}&#34;)
        return create_string_buffer(init, size)

    def inquire_modflow_binary_file_specs(
        self,
        filein: str | PathLike,
        fileout: str | PathLike | None,
        isim: int,
        itype: int,
    ) -&gt; dict:
        &#34;&#34;&#34;Report some of the details of a MODFLOW-written binary file.

        Parameters
        ----------
        filein : str or PathLike
            MODFLOW-generated binary file to be read.
        fileout : str, PathLike, None
            Output file with with table of array headers. Use None or &#34;&#34; for
            no output file.
        isim : int
            Inform the function the simulator that generated the binary file:

             * 1 = traditional MODFLOW
             * 21 = MODFLOW-USG with structured grid
             * 22 = MODFLOW-USG with unstructured grid
             * 31 = MODFLOW 6 with DIS grid
             * 32 = MODFLOW 6 with DISV grid
             * 33 = MODFLOW 6 with DISU grid

        itype : int
            Where 1 = system state or dependent variable;
            2 = cell-by-cell flows.

        Returns
        -------
        iprec : int
            Where 1 = single; 2 = double.
        narray : int
            Number of arrays.
        ntime : int
            Number of times.
        &#34;&#34;&#34;
        filein = Path(filein)
        if not filein.is_file():
            raise FileNotFoundError(f&#34;could not find filein {filein}&#34;)
        if fileout:
            fileout = Path(fileout)
        else:
            fileout = b&#34;&#34;
        validate_scalar(&#34;isim&#34;, isim, isin=[1, 21, 22, 31, 32, 33])
        validate_scalar(&#34;itype&#34;, itype, isin=[1, 2])
        iprec = c_int()
        narray = c_int()
        ntime = c_int()
        res = self.pestutils.inquire_modflow_binary_file_specs(
            byref(self.create_char_array(bytes(filein), &#34;LENFILENAME&#34;)),
            byref(self.create_char_array(bytes(fileout), &#34;LENFILENAME&#34;)),
            byref(c_int(isim)),
            byref(c_int(itype)),
            byref(iprec),
            byref(narray),
            byref(ntime),
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;inquired modflow binary file specs from %r&#34;, filein.name)
        return {
            &#34;iprec&#34;: iprec.value,
            &#34;narray&#34;: narray.value,
            &#34;ntime&#34;: ntime.value,
        }

    def retrieve_error_message(self) -&gt; str:
        &#34;&#34;&#34;Retrieve error message from library.

        Returns
        -------
        str
        &#34;&#34;&#34;
        from .ctypes_declarations import get_char_array

        charray = get_char_array(self.pestutils, &#34;LENMESSAGE&#34;)()
        res = self.pestutils.retrieve_error_message(byref(charray))
        return charray[:res].rstrip(b&#34;\x00&#34;).decode()

    def install_structured_grid(
        self,
        gridname: str,
        ncol: int,
        nrow: int,
        nlay: int,
        icorner: int,
        e0: float,
        n0: float,
        rotation: float,
        delr: float | npt.ArrayLike,
        delc: float | npt.ArrayLike,
    ) -&gt; None:
        &#34;&#34;&#34;Install specifications for a structured grid.

        Parameters
        ----------
        gridname : str
            Unique non-blank grid name.
        ncol, nrow, nlay : int
            Grid dimensions.
        icorner : int
            Reference corner, use 1 for top left and 2 for bottom left.
        e0, n0 : float
            Reference offsets.
        rotation : float
            Grid rotation, counter-clockwise degrees.
        &#34;&#34;&#34;
        validate_scalar(&#34;ncol&#34;, ncol, gt=0)
        validate_scalar(&#34;nrow&#34;, nrow, gt=0)
        validate_scalar(&#34;nlay&#34;, nlay, gt=0)
        col = ManyArrays(float_any={&#34;delr&#34;: delr}, ar_len=ncol)
        row = ManyArrays(float_any={&#34;delc&#34;: delc}, ar_len=nrow)
        col.validate(&#34;delr&#34;, gt=0.0)
        row.validate(&#34;delc&#34;, gt=0.0)
        validate_scalar(&#34;icorner&#34;, icorner, isin=[1, 2])
        res = self.pestutils.install_structured_grid(
            byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
            byref(c_int(ncol)),
            byref(c_int(nrow)),
            byref(c_int(nlay)),
            byref(c_int(icorner)),
            byref(c_double(e0)),
            byref(c_double(n0)),
            byref(c_double(rotation)),
            col.delr,
            row.delc,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;installed structured grid %r from specs&#34;, gridname)

    def get_cell_centres_structured(self, gridname: str, ncpl: int) -&gt; tuple:
        &#34;&#34;&#34;Get cell centres of a single layer of an installed structured grid.

        Parameters
        ----------
        gridname : str
            Name of installed structured grid.
        ncpl : int
            Dimensions of grid (nrow x ncol).

        Returns
        -------
        cellx, cellx : npt.NDArray[np.float64]
            Coordinates of cell centres with dimensions (ncpl,).
        &#34;&#34;&#34;
        cellx = np.zeros(ncpl, np.float64, order=&#34;F&#34;)
        celly = np.zeros(ncpl, np.float64, order=&#34;F&#34;)
        res = self.pestutils.get_cell_centres_structured(
            byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
            byref(c_int(ncpl)),
            cellx,
            celly,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(
            &#34;evaluated %d cell centres from structured grid %r&#34;, ncpl, gridname
        )
        return cellx.copy(&#34;A&#34;), celly.copy(&#34;A&#34;)

    def uninstall_structured_grid(self, gridname: str) -&gt; None:
        &#34;&#34;&#34;Uninstall structured grid set by :meth:`install_structured_grid`.

        Parameters
        ----------
        gridname : str
            Unique non-blank grid name.
        &#34;&#34;&#34;
        res = self.pestutils.uninstall_structured_grid(
            byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;))
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;uninstalled structured grid %r&#34;, gridname)

    def free_all_memory(self) -&gt; None:
        &#34;&#34;&#34;Deallocate all memory that is being used.&#34;&#34;&#34;
        ret = self.pestutils.free_all_memory()
        if ret != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;all memory was freed up&#34;)

    def interp_from_structured_grid(
        self,
        gridname: str,
        depvarfile: str | PathLike,
        isim: int,
        iprec: int | str | enum.Prec,
        ntime: int,
        vartype: str,
        interpthresh: float,
        nointerpval: float,
        # npts: int,  # determined from layer.shape[0]
        ecoord: npt.ArrayLike,
        ncoord: npt.ArrayLike,
        layer: int | npt.ArrayLike,
    ) -&gt; dict:
        &#34;&#34;&#34;Spatial interpolate points from a structured grid.

        Parameters
        ----------
        gridname : str
            Name of installed structured grid.
        depvarfile : str or PathLike
            Name of binary file to read.
        isim : int
            Specify -1 for MT3D; 1 for MODFLOW.
        iprec : int, str or enum.Prec
            Specify 1 or &#34;single&#34;, 2 or &#34;double&#34;, or use enum.Prec.
        ntime : int
            Number of output times.
        vartype : str
            Only read arrays of this type.
        interpthresh : float
            Absolute threshold for dry or inactive.
        nointerpval : float
            Value to use where interpolation is not possible.
        ecoord, ncoord : array_like
            X/Y or Easting/Northing coordinates for points with shape (npts,).
        layer : int or array_like
            Layers of points with shape (npts,).

        Returns
        -------
        nproctime : int
            Number of processed simulation times.
        simtime : npt.NDArray[np.float64]
            Simulation times, with shape (ntime,).
        simstate : npt.NDArray[np.float64]
            Interpolated system states, with shape (ntime, npts).
        &#34;&#34;&#34;
        depvarfile = Path(depvarfile)
        if not depvarfile.is_file():
            raise FileNotFoundError(f&#34;could not find depvarfile {depvarfile}&#34;)
        if isinstance(iprec, str):
            iprec = enum.Prec.get_value(iprec)
        pta = ManyArrays({&#34;ecoord&#34;: ecoord, &#34;ncoord&#34;: ncoord}, int_any={&#34;layer&#34;: layer})
        npts = len(pta)
        simtime = np.zeros(ntime, np.float64, order=&#34;F&#34;)
        simstate = np.zeros((ntime, npts), np.float64, order=&#34;F&#34;)
        nproctime = c_int()
        res = self.pestutils.interp_from_structured_grid(
            byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
            byref(self.create_char_array(bytes(depvarfile), &#34;LENFILENAME&#34;)),
            byref(c_int(isim)),
            byref(c_int(iprec)),
            byref(c_int(ntime)),
            byref(self.create_char_array(vartype, &#34;LENVARTYPE&#34;)),
            byref(c_double(interpthresh)),
            byref(c_double(nointerpval)),
            byref(c_int(npts)),
            pta.ecoord,
            pta.ncoord,
            pta.layer,
            byref(nproctime),
            simtime,
            simstate,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(
            &#34;interpolated %d points from structured grid %r&#34;, npts, gridname
        )
        return {
            &#34;nproctime&#34;: nproctime.value,
            &#34;simtime&#34;: simtime.copy(&#34;A&#34;),
            &#34;simstate&#34;: simstate.copy(&#34;A&#34;),
        }

    def interp_to_obstime(
        self,
        # nsimtime: int,  # determined from simval.shape[0]
        nproctime: int,
        # npts: int,  # determined from simval.shape[1]
        simtime: npt.ArrayLike,
        simval: npt.ArrayLike,
        interpthresh: float,
        how_extrap: str,
        time_extrap: float,
        nointerpval: float,
        # nobs: int,  # determined from obspoint.shape[0]
        obspoint: npt.ArrayLike,
        obstime: npt.ArrayLike,
    ) -&gt; npt.NDArray[np.float64]:
        &#34;&#34;&#34;Temporal interpolation for simulation times to observed times.

        Parameters
        ----------
        nproctime : int
            Number of times featured in simtime and simval.
        simtime : array_like
            1D array of simulation times with shape (nsimtime,).
        simval : array_like
            2D array of simulated values with shape (nsimtime, npts).
        interpthresh : float
            Values equal or above this in simval have no meaning.
        how_extrap : str
            Method, where &#39;L&#39;=linear; &#39;C&#39;=constant.
        time_extrap : float
            Permitted extrapolation time.
        nointerpval : float
            Value to use where interpolation is not possible.
        obspoint : array_like
            1D integer array of indices of observation points,
            which start at 0 and -1 means no index. Shape is (nobs,).
        obstime : array_like
            1D array of observation times with shape (nobs,).

        Returns
        -------
        np.ndarray
            Time-interpolated simulation values with shape (nobs,).
        &#34;&#34;&#34;
        simtime = np.array(simtime, dtype=np.float64, order=&#34;F&#34;, copy=False)
        simval = np.array(simval, dtype=np.float64, order=&#34;F&#34;, copy=False)
        obspoint = np.array(obspoint, order=&#34;F&#34;, copy=False)
        obstime = np.array(obstime, dtype=np.float64, order=&#34;F&#34;, copy=False)
        if simtime.ndim != 1:
            raise ValueError(&#34;expected &#39;simtime&#39; to have ndim=1&#34;)
        elif simval.ndim != 2:
            raise ValueError(&#34;expected &#39;simval&#39; to have ndim=2&#34;)
        elif obspoint.ndim != 1:
            raise ValueError(&#34;expected &#39;obspoint&#39; to have ndim=1&#34;)
        elif obstime.ndim != 1:
            raise ValueError(&#34;expected &#39;obstime&#39; to have ndim=1&#34;)
        elif not np.issubdtype(obspoint.dtype, np.integer):
            raise ValueError(
                f&#34;expected &#39;obspoint&#39; to be integer type; found {obspoint.dtype}&#34;
            )
        nsimtime, npts = simval.shape
        nobs = len(obspoint)
        obssimval = np.zeros(nobs, np.float64, order=&#34;F&#34;)
        res = self.pestutils.interp_to_obstime(
            byref(c_int(nsimtime)),
            byref(c_int(nproctime)),
            byref(c_int(npts)),
            simtime,
            simval,
            byref(c_double(interpthresh)),
            byref(c_char(how_extrap.encode())),
            byref(c_double(time_extrap)),
            byref(c_double(nointerpval)),
            byref(c_int(nobs)),
            obspoint.astype(np.int32, copy=False),
            obstime,
            obssimval,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;interpolated %d time points to %d observations&#34;, npts, nobs)
        return obssimval.copy(&#34;A&#34;)

    def install_mf6_grid_from_file(
        self, gridname: str, grbfile: str | PathLike
    ) -&gt; dict:
        &#34;&#34;&#34;Install specifications for a MF6 grid from a GRB file.

        Parameters
        ----------
        gridname : str
            Unique non-blank grid name.
        grbfile : str or PathLike
            Path to a GRB binary grid file.

        Returns
        -------
        idis : int
            Where 1 is for DIS and 2 is for DISV.
        ncells : int
            Number of cells in the grid.
        ndim1, ndim2, ndim3 : int
            Grid dimensions.
        &#34;&#34;&#34;
        grbfile = Path(grbfile)
        if not grbfile.is_file():
            raise FileNotFoundError(f&#34;could not find grbfile {grbfile}&#34;)
        idis = c_int()
        ncells = c_int()
        ndim1 = c_int()
        ndim2 = c_int()
        ndim3 = c_int()
        res = self.pestutils.install_mf6_grid_from_file(
            byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
            byref(self.create_char_array(bytes(grbfile), &#34;LENFILENAME&#34;)),
            byref(idis),
            byref(ncells),
            byref(ndim1),
            byref(ndim2),
            byref(ndim3),
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(
            &#34;installed mf6 grid %r from grbfile=%r&#34;, gridname, grbfile.name
        )
        return {
            &#34;idis&#34;: idis.value,
            &#34;ncells&#34;: ncells.value,
            &#34;ndim1&#34;: ndim1.value,
            &#34;ndim2&#34;: ndim2.value,
            &#34;ndim3&#34;: ndim3.value,
        }

    def get_cell_centres_mf6(self, gridname: str, ncells: int) -&gt; tuple:
        &#34;&#34;&#34;Get cell centres from an installed MF6 grid.

        Parameters
        ----------
        gridname : str
            Name of installed MF6 grid.
        ncells : int
            Dimensions of grid.

        Returns
        -------
        cellx, cellx, cellz : npt.NDArray[np.float64]
            Coordinates of cell centres with dimensions (ncells,).
        &#34;&#34;&#34;
        cellx = np.zeros(ncells, np.float64, order=&#34;F&#34;)
        celly = np.zeros(ncells, np.float64, order=&#34;F&#34;)
        cellz = np.zeros(ncells, np.float64, order=&#34;F&#34;)
        res = self.pestutils.get_cell_centres_mf6(
            byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
            byref(c_int(ncells)),
            cellx,
            celly,
            cellz,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;evaluated %d cell centres from MF6 grid %r&#34;, ncells, gridname)
        return cellx.copy(&#34;A&#34;), celly.copy(&#34;A&#34;), cellz.copy(&#34;A&#34;)

    def uninstall_mf6_grid(self, gridname: str) -&gt; None:
        &#34;&#34;&#34;Uninstall MF6 grid set by :meth:`install_mf6_grid_from_file`.

        Parameters
        ----------
        gridname : str
            Unique non-blank grid name.
        &#34;&#34;&#34;
        res = self.pestutils.uninstall_mf6_grid(
            byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;))
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;uninstalled mf6 grid %r&#34;, gridname)

    def calc_mf6_interp_factors(
        self,
        gridname: str,
        # npts: int,  # determined from ecoord.shape[0]
        ecoord: npt.ArrayLike,
        ncoord: npt.ArrayLike,
        layer: int | npt.ArrayLike,
        factorfile: str | PathLike,
        factorfiletype: int | str | enum.FactorFileType,
        blnfile: str | PathLike,
    ) -&gt; npt.NDArray[np.int32]:
        &#34;&#34;&#34;Calculate interpolation factors from a MODFLOW 6 DIS or DISV.

        Parameters
        ----------
        gridname : str
            Unique non-blank grid name.
        ecoord, ncoord : array_like
            X/Y or Easting/Northing coordinates for points with shape (npts,).
        layer : int or array_like
            Layers of points with shape (npts,).
        factorfile : str or PathLike
            File for kriging factors to write.
        factorfiletype : int, str or enum.FactorFileType
            Factor file type, where 0:binary, 1:text.
        blnfile : str or PathLike
            Name of bln file to write.

        Returns
        -------
        npt.NDArray[np.int32]
            Array interp_success(npts), where 1 is success and 0 is failure.
        &#34;&#34;&#34;
        pta = ManyArrays({&#34;ecoord&#34;: ecoord, &#34;ncoord&#34;: ncoord}, int_any={&#34;layer&#34;: layer})
        npts = len(pta)
        factorfile = Path(factorfile)
        if isinstance(factorfiletype, str):
            factorfiletype = enum.FactorFileType.get_value(factorfiletype)
        blnfile = Path(blnfile)
        interp_success = np.zeros(npts, np.int32, order=&#34;F&#34;)
        res = self.pestutils.calc_mf6_interp_factors(
            byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
            byref(c_int(npts)),
            pta.ecoord,
            pta.ncoord,
            pta.layer,
            byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
            byref(c_int(factorfiletype)),
            byref(self.create_char_array(bytes(blnfile), &#34;LENFILENAME&#34;)),
            interp_success,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;calculated mf6 interp factors for %r&#34;, gridname)
        return interp_success.copy(&#34;A&#34;)

    def interp_from_mf6_depvar_file(
        self,
        depvarfile: str | PathLike,
        factorfile: str | PathLike,
        factorfiletype: int | str | enum.FactorFileType,
        ntime: int,
        vartype: str,
        interpthresh: float,
        reapportion: int | bool,
        nointerpval: float,
        npts: int,
    ) -&gt; dict:
        &#34;&#34;&#34;
        Interpolate points using previously-calculated interpolation factors.

        Parameters
        ----------
        depvarfile : str or PathLike
            Name of binary file to read.
        factorfile : str or PathLike
            File containing spatial interpolation factors, written by
            :meth:`calc_mf6_interp_factors`.
        factorfiletype : int, str or enum.FactorFileType
            Use 0 for binary; 1 for text.
        ntime : int
            Number of output times.
        vartype : str
            Only read arrays of this type.
        interpthresh : float
            Absolute threshold for dry or inactive.
        reapportion : int or bool
            Use 0 for no (False); 1 for yes (True).
        nointerpval : float
            Value to use where interpolation is not possible.
        npts : int
            Number of points for interpolation.

        Returns
        -------
        nproctime : int
            Number of processed simulation times.
        simtime : npt.NDArray[np.float64]
            Simulation times, with shape (ntime,).
        simstate : npt.NDArray[np.float64]
            Interpolated system states, with shape (ntime, npts).
        &#34;&#34;&#34;
        depvarfile = Path(depvarfile)
        if not depvarfile.is_file():
            raise FileNotFoundError(f&#34;could not find depvarfile {depvarfile}&#34;)
        factorfile = Path(factorfile)
        if not factorfile.is_file():
            raise FileNotFoundError(f&#34;could not find factorfile {factorfile}&#34;)
        if isinstance(factorfiletype, str):
            factorfiletype = enum.FactorFileType.get_value(factorfiletype)
        simtime = np.zeros(ntime, np.float64, order=&#34;F&#34;)
        simstate = np.zeros((ntime, npts), np.float64, order=&#34;F&#34;)
        nproctime = c_int()
        res = self.pestutils.interp_from_mf6_depvar_file(
            byref(self.create_char_array(bytes(depvarfile), &#34;LENFILENAME&#34;)),
            byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
            byref(c_int(factorfiletype)),
            byref(c_int(ntime)),
            byref(self.create_char_array(vartype, &#34;LENVARTYPE&#34;)),
            byref(c_double(interpthresh)),
            byref(c_int(reapportion)),
            byref(c_double(nointerpval)),
            byref(c_int(npts)),
            byref(nproctime),
            simtime,
            simstate,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(
            &#34;interpolated %d points from mf6 depvar file %r&#34;, npts, depvarfile.name
        )
        return {
            &#34;nproctime&#34;: nproctime.value,
            &#34;simtime&#34;: simtime.copy(&#34;A&#34;),
            &#34;simstate&#34;: simstate.copy(&#34;A&#34;),
        }

    def extract_flows_from_cbc_file(
        self,
        cbcfile: str | PathLike,
        flowtype: str,
        isim: int,
        iprec: int | str | enum.Prec,
        # ncell: int,  # from izone.shape[0]
        izone: npt.ArrayLike,
        nzone: int,
        ntime: int,
    ) -&gt; dict:
        &#34;&#34;&#34;
        Read and accumulates flows from a CBC flow file to a user-specified BC.

        Parameters
        ----------
        cbcfile : str | PathLike
            Cell-by-cell flow term file written by any MF version.
        flowtype : str
            Type of flow to read.
        isim : int
            Simulator type.
        iprec : int, str or enum.Prec
            Precision used to record real variables in cbc file.
        izone : array_like
            Zonation of model domain, with shape (ncell,).
        nzone : int
            Equals or exceeds number of zones; zone 0 doesn&#39;t count.
        ntime : int
            Equals or exceed number of model output times for flow type.

        Returns
        -------
        numzone : int
            Number of non-zero-valued zones.
        zonenumber : npt.NDArray[np.int32]
            Zone numbers, with shape (nzone,).
        nproctime : int
            Number of processed simulation times.
        timestep : npt.NDArray[np.int32]
            Simulation time step, with shape (ntime,).
        stressperiod : npt.NDArray[np.int32]
            Simulation stress period, with shape (ntime,).
        simtime : npt.NDArray[np.int32]
            Simulation time, with shape (ntime,).
            A time of -1.0 indicates unknown.
        simflow : npt.NDArray[np.int32]
            Interpolated flows, with shape (ntime, nzone).
        &#34;&#34;&#34;
        cbcfile = Path(cbcfile)
        if not cbcfile.is_file():
            raise FileNotFoundError(f&#34;could not find cbcfile {cbcfile}&#34;)
        validate_scalar(&#34;flowtype&#34;, flowtype, minlen=1)
        validate_scalar(&#34;iprec&#34;, iprec, enum=enum.Prec)
        if isinstance(iprec, str):
            iprec = enum.Prec.get_value(iprec)
        cell = ManyArrays(int_any={&#34;izone&#34;: izone})
        ncell = len(cell)
        numzone = c_int()
        zonenumber = np.zeros(nzone, np.int32, order=&#34;F&#34;)
        nproctime = c_int()
        timestep = np.zeros(ntime, np.int32, order=&#34;F&#34;)
        stressperiod = np.zeros(ntime, np.int32, order=&#34;F&#34;)
        simtime = np.zeros(ntime, np.float64, order=&#34;F&#34;)
        simflow = np.zeros((ntime, nzone), np.float64, order=&#34;F&#34;)
        res = self.pestutils.extract_flows_from_cbc_file(
            byref(self.create_char_array(bytes(cbcfile), &#34;LENFILENAME&#34;)),
            byref(self.create_char_array(flowtype, &#34;LENFLOWTYPE&#34;)),
            byref(c_int(isim)),
            byref(c_int(iprec)),
            byref(c_int(ncell)),
            cell.izone,
            byref(c_int(nzone)),
            byref(numzone),
            zonenumber,
            byref(c_int(ntime)),
            byref(nproctime),
            timestep,
            stressperiod,
            simtime,
            simflow,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;extracted flows from %r&#34;, cbcfile.name)
        return {
            &#34;numzone&#34;: numzone.value,
            &#34;zonenumber&#34;: zonenumber.copy(&#34;A&#34;),
            &#34;nproctime&#34;: nproctime.value,
            &#34;timestep&#34;: timestep.copy(&#34;A&#34;),
            &#34;stressperiod&#34;: stressperiod.copy(&#34;A&#34;),
            &#34;simtime&#34;: simtime.copy(&#34;A&#34;),
            &#34;simflow&#34;: simflow.copy(&#34;A&#34;),
        }

    def calc_kriging_factors_2d(
        self,
        # npts: int,  # determined from ecs.shape[0]
        ecs: npt.ArrayLike,
        ncs: npt.ArrayLike,
        zns: int | npt.ArrayLike,
        # mpts: int,  # determined from ect.shape[0]
        ect: npt.ArrayLike,
        nct: npt.ArrayLike,
        znt: int | npt.ArrayLike,
        vartype: int | str | enum.VarioType,
        krigtype: int | str | enum.KrigType,
        aa: float | npt.ArrayLike,
        anis: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        searchrad: float,
        maxpts: int,
        minpts: int,
        factorfile: str | PathLike,
        factorfiletype: int | str | enum.FactorFileType,
    ) -&gt; int:
        &#34;&#34;&#34;
        Calculate 2D kriging factors.

        Parameters
        ----------
        ecs, ncs : array_like
            Source point coordinates, each 1D array with shape (npts,).
        zns : int or array_like
            Source point zones, integer or 1D array with shape (npts,).
        ect, nct : array_like
            Target point coordinates, each 1D array with shape (mpts,).
        znt : int or array_like
            Target point zones, integer or 1D array with shape (mpts,).
        vartype : int, str or enum.VarioType
            Variogram type, where 1:spher, 2:exp, 3:gauss, 4:pow.
        krigtype : int, str, or enum.KrigType,
            Kriging type, where 0:simple, 1:ordinary.
        aa : float or array_like
            Variogram &#34;a&#34; value, float or 1D array with shape (mpts,).
        anis : float or array_like
            Variogram anisotropies, float or 1D array with shape (mpts,).
        bearing : float or array_like
            Variogram bearings, float or 1D array with shape (mpts,).
        searchrad : float
            Search radius.
        maxpts, minpts : int
            Search specifications.
        factorfile : str or PathLike
            File for kriging factors.
        factorfiletype : int, str or enum.FactorFileType
            Factor file type, where 0:binary, 1:text.

        Returns
        -------
        int
            Number of interp points.
        &#34;&#34;&#34;
        npta = ManyArrays({&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs}, int_any={&#34;zns&#34;: zns})
        npts = len(npta)
        mpta = ManyArrays(
            {&#34;ect&#34;: ect, &#34;nct&#34;: nct},
            {&#34;aa&#34;: aa, &#34;anis&#34;: anis, &#34;bearing&#34;: bearing},
            {&#34;znt&#34;: znt},
        )
        mpts = len(mpta)
        if isinstance(vartype, str):
            vartype = enum.VarioType.get_value(vartype)
        if isinstance(krigtype, str):
            krigtype = enum.KrigType.get_value(krigtype)
        factorfile = Path(factorfile)
        if isinstance(factorfiletype, str):
            factorfiletype = enum.FactorFileType.get_value(factorfiletype)
        icount_interp = c_int()
        res = self.pestutils.calc_kriging_factors_2d(
            byref(c_int(npts)),
            npta.ecs,
            npta.ncs,
            npta.zns,
            byref(c_int(mpts)),
            mpta.ect,
            mpta.nct,
            mpta.znt,
            byref(c_int(vartype)),
            byref(c_int(krigtype)),
            mpta.aa,
            mpta.anis,
            mpta.bearing,
            byref(c_double(searchrad)),
            byref(c_int(maxpts)),
            byref(c_int(minpts)),
            byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
            byref(c_int(factorfiletype)),
            byref(icount_interp),
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;calculated 2D kriging factors to %r&#34;, factorfile.name)
        return icount_interp.value

    def calc_kriging_factors_auto_2d(
        self,
        # npts: int,  # determined from ecs.shape[0]
        ecs: npt.ArrayLike,
        ncs: npt.ArrayLike,
        zns: int | npt.ArrayLike,
        # mpts: int,  # determined from ect.shape[0]
        ect: npt.ArrayLike,
        nct: npt.ArrayLike,
        znt: int | npt.ArrayLike,
        krigtype: int | str | enum.KrigType,
        anis: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        factorfile: str | PathLike,
        factorfiletype: int | str | enum.FactorFileType,
    ) -&gt; int:
        &#34;&#34;&#34;
        Calculate 2D kriging factors, with automatic variogram properties.

        Parameters
        ----------
        ecs, ncs : array_like
            Source point coordinates, each 1D array with shape (npts,).
        zns : int or array_like
            Source point zones, integer or 1D array with shape (npts,).
        ect, nct : array_like
            Target point coordinates, each 1D array with shape (mpts,).
        znt : int or array_like
            Target point zones, integer or 1D array with shape (mpts,).
        krigtype : int, str, enum.KrigType
            Kriging type, where 0:simple, 1:ordinary.
        anis : float or array_like
            Variogram anisotropies, float or 1D array with shape (mpts,).
        bearing : float or array_like
            Variogram bearings, float or 1D array with shape (mpts,).
        factorfile : str or PathLike
            File for kriging factors.
        factorfiletype : int, str or enum.FactorFileType
            Factor file type, where 0:binary, 1:text.

        Returns
        -------
        int
            Number of interp points.
        &#34;&#34;&#34;
        npta = ManyArrays({&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs}, int_any={&#34;zns&#34;: zns})
        npts = len(npta)
        mpta = ManyArrays(
            {&#34;ect&#34;: ect, &#34;nct&#34;: nct}, {&#34;anis&#34;: anis, &#34;bearing&#34;: bearing}, {&#34;znt&#34;: znt}
        )
        mpts = len(mpta)
        if isinstance(krigtype, str):
            krigtype = enum.KrigType.get_value(krigtype)
        factorfile = Path(factorfile)
        if isinstance(factorfiletype, str):
            factorfiletype = enum.FactorFileType.get_value(factorfiletype)
        icount_interp = c_int()
        res = self.pestutils.calc_kriging_factors_auto_2d(
            byref(c_int(npts)),
            npta.ecs,
            npta.ncs,
            npta.zns,
            byref(c_int(mpts)),
            mpta.ect,
            mpta.nct,
            mpta.znt,
            byref(c_int(krigtype)),
            mpta.anis,
            mpta.bearing,
            byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
            byref(c_int(factorfiletype)),
            byref(icount_interp),
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;calculated 2D auto kriging factors to %r&#34;, factorfile.name)
        return icount_interp.value

    def calc_kriging_factors_3d(
        self,
        # npts: int,  # determined from ecs.shape[0]
        ecs: npt.ArrayLike,
        ncs: npt.ArrayLike,
        zcs: npt.ArrayLike,
        zns: int | npt.ArrayLike,
        # mpts: int,  # determined from ect.shape[0]
        ect: npt.ArrayLike,
        nct: npt.ArrayLike,
        zct: npt.ArrayLike,
        znt: int | npt.ArrayLike,
        zonenum: int | npt.ArrayLike,
        krigtype: int | str | enum.KrigType,
        # nzone: int,  # determined from shape[0] from any zonenum..rake else 1
        vartype: int | str | enum.VarioType | npt.ArrayLike,
        ahmax: float | npt.ArrayLike,
        ahmin: float | npt.ArrayLike,
        avert: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        dip: float | npt.ArrayLike,
        rake: float | npt.ArrayLike,
        srhmax: float,
        srhmin: float,
        srvert: float,
        maxpts: int,
        minpts: int,
        factorfile: str | PathLike,
        factorfiletype: int | str | enum.FactorFileType,
    ) -&gt; int:
        &#34;&#34;&#34;
        Calculate 3D kriging factors.

        Parameters
        ----------
        ecs, ncs, zcs : array_like
            Source point coordinates, each 1D array with shape (npts,).
        zns : int or array_like
            Source point zones, integer or 1D array with shape (npts,).
        ect, nct, zct : array_like
            Target point coordinates, each 1D array with shape (mpts,).
        znt : int or array_like
            Target point zones, integer or 1D array with shape (mpts,).
        krigtype : int, str, or enum.KrigType,
            Kriging type, where 0:simple, 1:ordinary.
        zonenum : int, or array_like
            Zone numbers, inteter or 1D array with shape (nzone,).
        vartype : int, str, enum.VarioType or array_like
            Variogram type, where 1:spher, 2:exp, 3:gauss, 4:pow. If array,
            then it should have shape (nzone,).
        ahmax, ahmin, avert : float or array_like
            Variogram &#34;a&#34; values in 3 orthogonal directions (hmax, hmin, vert).
            Each can be a float or 1D array with shape (nzone,).
        bearing : float or array_like
            Bearing of hmax, float or 1D array with shape (nzone,).
        dip : float or array_like
            Dip of hmax, float or 1D array with shape (nzone,).
        rake : float or array_like
            Twist about hmax axis, float or 1D array with shape (nzone,).
        srhmax, srhmin, srvert : float
            Search radius in hmax, hmin, and vert directions.
        maxpts, minpts : int
            Search specifications.
        factorfile : str or PathLike
            File for kriging factors.
        factorfiletype : int, str or enum.FactorFileType
            Factor file type, where 0:binary, 1:text.

        Returns
        -------
        int
            Number of interp points.
        &#34;&#34;&#34;
        npta = ManyArrays({&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs, &#34;zcs&#34;: zcs}, int_any={&#34;zns&#34;: zns})
        npts = len(npta)
        mpta = ManyArrays({&#34;ect&#34;: ect, &#34;nct&#34;: nct, &#34;zct&#34;: zct}, int_any={&#34;znt&#34;: znt})
        mpts = len(mpta)
        if isinstance(krigtype, str):
            krigtype = enum.KrigType.get_value(krigtype)
        vartype = np.array(vartype)
        if np.issubdtype(vartype.dtype, str):
            vartype = np.vectorize(enum.VarioType.get_value)(vartype)
        if not np.issubdtype(vartype.dtype, np.integer):
            raise ValueError(&#34;expected &#39;vartype&#39; to be integer, str or enum.VarioType&#34;)
        nzone = ManyArrays(
            float_any={
                &#34;ahmax&#34;: ahmax,
                &#34;ahmin&#34;: ahmin,
                &#34;avert&#34;: avert,
                &#34;bearing&#34;: bearing,
                &#34;dip&#34;: dip,
                &#34;rake&#34;: rake,
            },
            int_any={&#34;zonenum&#34;: zonenum, &#34;vartype&#34;: vartype},
        )
        factorfile = Path(factorfile)
        if isinstance(factorfiletype, str):
            factorfiletype = enum.FactorFileType.get_value(factorfiletype)
        icount_interp = c_int()
        res = self.pestutils.calc_kriging_factors_3d(
            byref(c_int(npts)),
            npta.ecs,
            npta.ncs,
            npta.zcs,
            npta.zns,
            byref(c_int(mpts)),
            mpta.ect,
            mpta.nct,
            mpta.zct,
            mpta.znt,
            byref(c_int(krigtype)),
            byref(c_int(len(nzone))),
            nzone.zonenum,
            nzone.vartype,
            nzone.ahmax,
            nzone.ahmin,
            nzone.avert,
            nzone.bearing,
            nzone.dip,
            nzone.rake,
            byref(c_double(srhmax)),
            byref(c_double(srhmin)),
            byref(c_double(srvert)),
            byref(c_int(maxpts)),
            byref(c_int(minpts)),
            byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
            byref(c_int(factorfiletype)),
            byref(icount_interp),
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;calculated 3D kriging factors to %r&#34;, factorfile.name)
        return icount_interp.value

    def krige_using_file(
        self,
        factorfile: str | PathLike,
        factorfiletype: int | str | enum.FactorFileType,
        # npts: int,  # determined from sourceval.shape[0]
        mpts: int,
        krigtype: int | str | enum.KrigType,
        transtype: int | str | enum.TransType,
        sourceval: npt.ArrayLike,
        meanval: float | npt.ArrayLike | None,
        nointerpval: float,
    ) -&gt; dict:
        &#34;&#34;&#34;
        Apply interpolation factors calculated by other functions.

        Parameters
        ----------
        factorfile : str or PathLike
            Input file with kriging factors.
        factorfiletype : int, str or enum.FactorFileType
            Factor file type, where 0:binary, 1:text.
        mpts : int
            Number of target points, used to compare with value in factor file.
        krigtype : int, str, or enum.KrigType,
            Kriging type, where 0:simple, 1:ordinary.
        transtype : int, str, enum.TransType
            Tranformation type, where 0 is none and 1 is log.
        sourceval : array_like
            Values at sources, 1D array with shape (npts,).
        meanval : float, array_like, optional
            Mean values are required if simple kriging, described as a float
            or 1D array with shape (mpts,).
        nointerpval : float
            Value to use where interpolation is not possible.

        Returns
        -------
        targval : npt.NDArray[np.float64]
            Values calculated for targets.
        icount_interp : int
            Number of interpolation pts.
        &#34;&#34;&#34;
        factorfile = Path(factorfile)
        if not factorfile.is_file():
            raise FileNotFoundError(f&#34;could not find factorfile {factorfile}&#34;)
        if isinstance(factorfiletype, str):
            factorfiletype = enum.FactorFileType.get_value(factorfiletype)
        if isinstance(krigtype, str):
            krigtype = enum.KrigType.get_value(krigtype)
        if isinstance(transtype, str):
            transtype = enum.TransType.get_value(transtype)
        npta = ManyArrays({&#34;sourceval&#34;: sourceval})
        npts = len(npta)
        if meanval is None:
            if krigtype == enum.KrigType.simple:
                self.logger.error(
                    &#34;simple kriging requires &#39;meanval&#39;; assuming zero for now&#34;
                )
            meanval = 0.0
        mpta = ManyArrays(float_any={&#34;meanval&#34;: meanval}, ar_len=mpts)
        targval = np.full(mpts, nointerpval, dtype=np.float64, order=&#34;F&#34;)
        icount_interp = c_int()
        res = self.pestutils.krige_using_file(
            byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
            byref(c_int(factorfiletype)),
            byref(c_int(npts)),
            byref(c_int(mpts)),
            byref(c_int(krigtype)),
            byref(c_int(transtype)),
            npta.sourceval,
            targval,
            byref(icount_interp),
            mpta.meanval,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;kriged using factor file %r&#34;, factorfile.name)
        return {
            &#34;targval&#34;: targval.copy(&#34;A&#34;),
            &#34;icount_interp&#34;: icount_interp.value,
        }

    def build_covar_matrix_2d(
        self,
        # npts: int,  # determined from ec.shape[0]
        ec: npt.ArrayLike,
        nc: npt.ArrayLike,
        zn: int | npt.ArrayLike,
        vartype: int | str | enum.VarioType,
        nugget: float | npt.ArrayLike,
        aa: float | npt.ArrayLike,
        sill: float | npt.ArrayLike,
        anis: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        ldcovmat: int,
    ) -&gt; npt.NDArray[np.float64]:
        &#34;&#34;&#34;
        Calculate a covariance matrix for a set of 2D pilot points.

        Parameters
        ----------
        ec, nc : array_like
            Pilot point coordinates, each 1D array with shape (npts,).
        zn : int or array_like
            Pilot point zones, integer or 1D array with shape (npts,).
        vartype : int, str or enum.VarioType
            Variogram type, where 1:spher, 2:exp, 3:gauss, 4:pow.
        nugget, aa, sill, anis, bearing : float or array_like
            Variogram parameters, each float or 1D array with shape (npts,).
        ldcovmat : int
            Leading dimension of covmat.

        Returns
        -------
        npt.NDArray[np.float64]
            2D matrix covmat(ldcovmat, npts).
        &#34;&#34;&#34;
        pta = ManyArrays(
            {&#34;ec&#34;: ec, &#34;nc&#34;: nc},
            {
                &#34;nugget&#34;: nugget,
                &#34;aa&#34;: aa,
                &#34;sill&#34;: sill,
                &#34;anis&#34;: anis,
                &#34;bearing&#34;: bearing,
            },
            {&#34;zn&#34;: zn},
        )
        npts = len(pta)
        if isinstance(vartype, str):
            vartype = enum.VarioType.get_value(vartype)
        covmat = np.zeros((ldcovmat, npts), np.float64, order=&#34;F&#34;)
        res = self.pestutils.build_covar_matrix_2d(
            byref(c_int(npts)),
            pta.ec,
            pta.nc,
            pta.zn,
            byref(c_int(vartype)),
            pta.nugget,
            pta.aa,
            pta.sill,
            pta.anis,
            pta.bearing,
            byref(c_int(ldcovmat)),
            covmat,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;calculated covariance matrix for %d 2D pilot points&#34;, npts)
        return covmat.copy(&#34;A&#34;)

    def build_covar_matrix_3d(
        self,
        # npts: int,  # determined from ec.shape[0]
        ec: npt.ArrayLike,
        nc: npt.ArrayLike,
        zc: npt.ArrayLike,
        zn: int | npt.ArrayLike,
        vartype: int | str | enum.VarioType,
        nugget: float | npt.ArrayLike,
        sill: float | npt.ArrayLike,
        ahmax: float | npt.ArrayLike,
        ahmin: float | npt.ArrayLike,
        avert: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        dip: float | npt.ArrayLike,
        rake: float | npt.ArrayLike,
        ldcovmat: int,
    ) -&gt; npt.NDArray[np.float64]:
        &#34;&#34;&#34;
        Calculate a covariance matrix for a set of 3D pilot points.

        Parameters
        ----------
        ec, nc, zc: array_like
            Pilot point coordinates, each 1D array with shape (npts,).
        zn : int or array_like
            Pilot point zones, integer or 1D array with shape (npts,).
        vartype : int, str or enum.VarioType
            Variogram type, where 1:spher, 2:exp, 3:gauss, 4:pow.
        nugget, sill : float or array_like
            Variogram parameters, each float or 1D array with shape (npts,).
        ahmax, ahmin, avert : float or array_like
            Variogram a parameters, each float or 1D array with shape (npts,).
        bearing, dip, rake : float or array_like
            Variogram angles, each float or 1D array with shape (npts,).
        ldcovmat : int
            Leading dimension of covmat.

        Returns
        -------
        npt.NDArray[np.float64]
            2D matrix covmat(ldcovmat, npts).
        &#34;&#34;&#34;
        pta = ManyArrays(
            {&#34;ec&#34;: ec, &#34;nc&#34;: nc, &#34;zc&#34;: zc},
            {
                &#34;nugget&#34;: nugget,
                &#34;sill&#34;: sill,
                &#34;ahmax&#34;: ahmax,
                &#34;ahmin&#34;: ahmin,
                &#34;avert&#34;: avert,
                &#34;bearing&#34;: bearing,
                &#34;dip&#34;: dip,
                &#34;rake&#34;: rake,
            },
            {&#34;zn&#34;: zn},
        )
        npts = len(pta)
        if isinstance(vartype, str):
            vartype = enum.VarioType.get_value(vartype)
        covmat = np.zeros((ldcovmat, npts), np.float64, order=&#34;F&#34;)
        res = self.pestutils.build_covar_matrix_3d(
            byref(c_int(npts)),
            pta.ec,
            pta.nc,
            pta.zc,
            pta.zn,
            byref(c_int(vartype)),
            pta.nugget,
            pta.sill,
            pta.ahmax,
            pta.ahmin,
            pta.avert,
            pta.bearing,
            pta.dip,
            pta.rake,
            byref(c_int(ldcovmat)),
            covmat,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;calculated covariance matrix for %d 3D pilot points&#34;, npts)
        return covmat.copy(&#34;A&#34;)

    def calc_structural_overlay_factors(
        self,
        # npts: int,  # determined from ecs.shape[0]
        ecs: npt.ArrayLike,
        ncs: npt.ArrayLike,
        ids: int | npt.ArrayLike,
        conwidth: npt.ArrayLike,
        aa: npt.ArrayLike,
        structype: int | str | enum.StrucType,
        inverse_power: float,
        # mpts: int,  # determined from ect.shape[0]
        ect: npt.ArrayLike,
        nct: npt.ArrayLike,
        active: int | npt.ArrayLike,
        factorfile: str | PathLike,
        factorfiletype: int | str | enum.FactorFileType,
    ) -&gt; int:
        &#34;&#34;&#34;
        Calculate interpolation/blending factors for structural overlay parameters.

        Parameters
        ----------
        ecs, ncs : array_like
            Source point coordinates, each 1D array with shape (npts,).
        ids : int or array_like
            Source point structure number, integer or 1D array with shape (npts,).
        conwidth, aa : float or array_like
            Blending parameters, float or 1D array with shape (npts,).
        structype : int, str or enum.StrucType
            Structure type, where 0 is polylinear and 1 is polygonal.
        inverse_power : float
            Inverse power of distance.
        ect, nct : array_like
            Target point coordinates, each 1D array with shape (mpts,).
        active : int or array_like
            Target point activity, integer or 1D array with shape (mpts,).
        factorfile : str or PathLike
            File for kriging factors.
        factorfiletype : int, str or enum.FactorFileType
            Factor file type, where 0:binary, 1:text.

        Returns
        -------
        int
            Number of interp points.
        &#34;&#34;&#34;
        npta = ManyArrays(
            {&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs}, {&#34;conwidth&#34;: conwidth, &#34;aa&#34;: aa}, {&#34;ids&#34;: ids}
        )
        npts = len(npta)
        mpta = ManyArrays({&#34;ect&#34;: ect, &#34;nct&#34;: nct}, int_any={&#34;active&#34;: active})
        mpts = len(mpta)
        if isinstance(structype, str):
            structype = enum.StrucType.get_value(structype)
        factorfile = Path(factorfile)
        if isinstance(factorfiletype, str):
            factorfiletype = enum.FactorFileType.get_value(factorfiletype)
        icount_interp = c_int()
        res = self.pestutils.calc_structural_overlay_factors(
            byref(c_int(npts)),
            npta.ecs,
            npta.ncs,
            npta.ids,
            npta.conwidth,
            npta.aa,
            byref(c_int(structype)),
            byref(c_double(inverse_power)),
            byref(c_int(mpts)),
            mpta.ect,
            mpta.nct,
            mpta.active,
            byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
            byref(c_int(factorfiletype)),
            byref(icount_interp),
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(
            &#34;calculated interpolation/blending factors to %r&#34;, factorfile.name
        )
        return icount_interp.value

    def interpolate_blend_using_file(
        self,
        factorfile: str | PathLike,
        factorfiletype: int | str | enum.FactorFileType,
        # npts: int,  # determined from sourceval.shape[0]
        # mpts: int,  # determined from targval.shape[0]
        transtype: int | str | enum.TransType,
        lt_target: str | bool,
        gt_target: str | bool,
        sourceval: npt.ArrayLike,
        targval: npt.ArrayLike,
    ) -&gt; dict:
        &#34;&#34;&#34;
        Apply interpolation factors calculated by :meth:`calc_structural_overlay_factors`.

        Parameters
        ----------
        factorfile : str or PathLike
            File for kriging factors.
        factorfiletype : int, str or enum.FactorFileType
            Factor file type, where 0:binary, 1:text.
        transtype : int, str, enum.TransType
            Tranformation type, where 0 is none and 1 is log.
        lt_target, gt_target : str or bool
            Whether to undercut or exceed target, use &#34;Y&#34;/&#34;N&#34; or bool.
        sourceval : array_like
            Values at sources, 1D array with shape (npts,).
        targval : array_like
            Values at targets, 1D array with shape (mpts,).

        Returns
        -------
        targval : npt.NDArray[np.float64]
            Values calculated for targets.
        icount_interp : int
            Number of interpolation pts.
        &#34;&#34;&#34;
        factorfile = Path(factorfile)
        if not factorfile.is_file():
            raise FileNotFoundError(f&#34;could not find factorfile {factorfile}&#34;)
        if isinstance(factorfiletype, str):
            factorfiletype = enum.FactorFileType.get_value(factorfiletype)
        if isinstance(transtype, str):
            transtype = enum.TransType.get_value(transtype)
        if isinstance(lt_target, bool):
            lt_target = &#34;y&#34; if lt_target else &#34;n&#34;
        if isinstance(gt_target, bool):
            gt_target = &#34;y&#34; if gt_target else &#34;n&#34;
        npta = ManyArrays({&#34;sourceval&#34;: sourceval})
        npts = len(npta)
        mpta = ManyArrays({&#34;targval&#34;: targval})
        mpts = len(mpta)
        icount_interp = c_int()
        res = self.pestutils.interpolate_blend_using_file(
            byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
            byref(c_int(factorfiletype)),
            byref(c_int(npts)),
            byref(c_int(mpts)),
            byref(c_int(transtype)),
            byref(c_char(lt_target.encode())),
            byref(c_char(gt_target.encode())),
            npta.sourceval,
            mpta.targval,
            byref(icount_interp),
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;applied interpolation factors from %r&#34;, factorfile.name)
        return {
            &#34;targval&#34;: mpts.targval.copy(&#34;A&#34;),
            &#34;icount_interp&#34;: icount_interp.value,
        }

    def ipd_interpolate_2d(
        self,
        # npts: int,  # determined from ecs.shape[0]
        ecs: npt.ArrayLike,
        ncs: npt.ArrayLike,
        zns: int | npt.ArrayLike,
        sourceval: npt.ArrayLike,
        # mpts: int,  # determined from ect.shape[0]
        ect: npt.ArrayLike,
        nct: npt.ArrayLike,
        znt: int | npt.ArrayLike,
        transtype: int | str | enum.TransType,
        anis: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        invpow: float | npt.ArrayLike,
    ) -&gt; npt.NDArray[np.float64]:
        &#34;&#34;&#34;Undertake 2D inverse-power-of-distance spatial interpolation.

        Parameters
        ----------
        ecs, ncs : array_like
            Source point coordinates, each 1D array with shape (npts,).
        zns : int or array_like
            Source point zones, integer or 1D array with shape (npts,).
        sourceval : array_like
            Source values, 1D array with shape (npts,).
        ect, nct : array_like
            Target point coordinates, each 1D array with shape (mpts,).
        znt : int or array_like
            Target point zones, integer or 1D array with shape (mpts,).
        transtype : int, str, enum.TransType
            Tranformation type, where 0 is none and 1 is log.
        anis : float or array_like
            Local anisotropy, float or 1D array with shape (mpts,).
        bearing : float or array_like
            Local anisotropy bearing, float or 1D array with shape (mpts,).
        invpow : float or array_like
            Local inverse power of distance, float or 1D array with shape (mpts,).

        Returns
        -------
        npt.NDArray[np.float64]
            Values calculated for targets.
        &#34;&#34;&#34;
        npta = ManyArrays(
            {&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs, &#34;sourceval&#34;: sourceval}, int_any={&#34;zns&#34;: zns}
        )
        npts = len(npta)
        mpta = ManyArrays(
            {&#34;ect&#34;: ect, &#34;nct&#34;: nct},
            {&#34;anis&#34;: anis, &#34;bearing&#34;: bearing, &#34;invpow&#34;: invpow},
            {&#34;znt&#34;: znt},
        )
        mpts = len(mpta)
        if isinstance(transtype, str):
            transtype = enum.TransType.get_value(transtype)
        targval = np.zeros(mpts, np.float64, order=&#34;F&#34;)
        res = self.pestutils.ipd_interpolate_2d(
            byref(c_int(npts)),
            npta.ecs,
            npta.ncs,
            npta.zns,
            npta.sourceval,
            byref(c_int(mpts)),
            mpta.ect,
            mpta.nct,
            mpta.znt,
            targval,
            byref(c_int(transtype)),
            mpta.anis,
            mpta.bearing,
            mpta.invpow,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;undertook 2D inverse-power-of-distance spatial interpolation&#34;)
        return targval.copy(&#34;A&#34;)

    def ipd_interpolate_3d(
        self,
        # npts: int,  # determined from ecs.shape[0]
        ecs: npt.ArrayLike,
        ncs: npt.ArrayLike,
        zcs: npt.ArrayLike,
        zns: int | npt.ArrayLike,
        sourceval: npt.ArrayLike,
        # mpts: int,  # determined from ect.shape[0]
        ect: npt.ArrayLike,
        nct: npt.ArrayLike,
        zct: npt.ArrayLike,
        znt: int | npt.ArrayLike,
        transtype: int | str | enum.TransType,
        ahmax: float | npt.ArrayLike,
        ahmin: float | npt.ArrayLike,
        avert: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        dip: float | npt.ArrayLike,
        rake: float | npt.ArrayLike,
        invpow: float | npt.ArrayLike,
    ) -&gt; npt.NDArray[np.float64]:
        &#34;&#34;&#34;Undertake 3D inverse-power-of-distance spatial interpolation.

        Parameters
        ----------
        ecs, ncs, zcs : array_like
            Source point coordinates, each 1D array with shape (npts,).
        zns : int or array_like
            Source point zones, integer or 1D array with shape (npts,).
        sourceval : array_like
            Source values, 1D array with shape (npts,).
        ect, nct, zct : array_like
            Target point coordinates, each 1D array with shape (mpts,).
        znt : int or array_like
            Target point zones, integer or 1D array with shape (mpts,).
        transtype : int, str, enum.TransType
            Tranformation type, where 0 is none and 1 is log.
        ahmax, ahmin, avert : float or array_like
            Relative correlation lengths, float or 1D array with shape (mpts,).
        bearing, dip, rake : float or array_like
            Correlation directions, float or 1D array with shape (mpts,).
        invpow : float or array_like
            Local inverse power of distance, float or 1D array with shape (mpts,).

        Returns
        -------
        npt.NDArray[np.float64]
            Values calculated for targets.
        &#34;&#34;&#34;
        npta = ManyArrays(
            {&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs, &#34;zcs&#34;: zcs, &#34;sourceval&#34;: sourceval},
            int_any={&#34;zns&#34;: zns},
        )
        npts = len(npta)
        mpta = ManyArrays(
            {&#34;ect&#34;: ect, &#34;nct&#34;: nct, &#34;zct&#34;: zct},
            {
                &#34;ahmax&#34;: ahmax,
                &#34;ahmin&#34;: ahmin,
                &#34;avert&#34;: avert,
                &#34;bearing&#34;: bearing,
                &#34;dip&#34;: dip,
                &#34;rake&#34;: rake,
                &#34;invpow&#34;: invpow,
            },
            {&#34;znt&#34;: znt},
        )
        mpts = len(mpta)
        if isinstance(transtype, str):
            transtype = enum.TransType.get_value(transtype)
        targval = np.zeros(mpts, np.float64, order=&#34;F&#34;)
        res = self.pestutils.ipd_interpolate_3d(
            byref(c_int(npts)),
            npta.ecs,
            npta.ncs,
            npta.zcs,
            npta.zns,
            npta.sourceval,
            byref(c_int(mpts)),
            mpta.ect,
            mpta.nct,
            mpta.zct,
            mpta.znt,
            targval,
            byref(c_int(transtype)),
            mpta.ahmax,
            mpta.ahmin,
            mpta.avert,
            mpta.bearing,
            mpta.dip,
            mpta.rake,
            mpta.invpow,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;undertook 3D inverse-power-of-distance spatial interpolation&#34;)
        return targval.copy(&#34;A&#34;)

    def initialize_randgen(self, iseed: int) -&gt; None:
        &#34;&#34;&#34;
        Initialize the random number generator.

        Parameters
        ----------
        iseed : int
            Seed value.
        &#34;&#34;&#34;
        res = self.pestutils.initialize_randgen(byref(c_int(iseed)))
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;initialized the random number generator&#34;)

    def fieldgen2d_sva(
        self,
        # nnode: int,  # determined from ec.shape[0]
        ec: npt.ArrayLike,
        nc: npt.ArrayLike,
        area: float | npt.ArrayLike,
        active: int | npt.ArrayLike,
        mean: float | npt.ArrayLike,
        var: float | npt.ArrayLike,
        aa: float | npt.ArrayLike,
        anis: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        transtype: int | str | enum.TransType,
        avetype: int | str | enum.VarioType,
        power: float,
        # ldrand: int,  # same as nnode
        nreal: int,
    ) -&gt; npt.NDArray[np.float64]:
        &#34;&#34;&#34;
        Generate 2D stochastic fields based on a spatially varying variogram.

        Parameters
        ----------
        ec, nc : array_like
            Model grid coordinates, each 1D array with shape (nnode,).
        area : float or array_like
            Areas of grid cells.
        active : int or array_like
            Inactive grid cells are equal to zero.
        mean : float or array_like
            Mean value of stochastic field.
        var : float or array_like
            Variance of stochastic field.
        aa : float or array_like
            Averaging function spatial dimension.
        anis : float or array_like
            Anisotropy ratio.
        bearing : float or array_like
            Bearing of principal anisotropy axis.
        transtype : int, str or enum.TransType
            Stochastic field pertains to natural(0) or log(1) properties.
        avetype : int, str or enum.VarioType
            Averaging function type, where 1:spher, 2:exp, 3:gauss, 4:pow.
        power : float
            Power used if avetype is 4 (pow).
        nreal : int
            Number of realisations to generate.

        Returns
        -------
        npt.NDArray[np.float64]
            Realisations with shape (nnode, nreal).
        &#34;&#34;&#34;
        node = ManyArrays(
            {&#34;ec&#34;: ec, &#34;nc&#34;: nc},
            {
                &#34;area&#34;: area,
                &#34;mean&#34;: mean,
                &#34;var&#34;: var,
                &#34;aa&#34;: aa,
                &#34;anis&#34;: anis,
                &#34;bearing&#34;: bearing,
            },
            {&#34;active&#34;: active},
        )
        if isinstance(transtype, str):
            transtype = enum.TransType.get_value(transtype)
        if isinstance(avetype, str):
            avetype = enum.VarioType.get_value(avetype)
        ldrand = nnode = len(node)
        randfield = np.zeros((ldrand, nreal), np.float64, order=&#34;F&#34;)
        res = self.pestutils.fieldgen2d_sva(
            byref(c_int(nnode)),
            node.ec,
            node.nc,
            node.area,
            node.active,
            node.mean,
            node.var,
            node.aa,
            node.anis,
            node.bearing,
            byref(c_int(transtype)),
            byref(c_int(avetype)),
            byref(c_double(power)),
            byref(c_int(ldrand)),
            byref(c_int(nreal)),
            randfield,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;generated 2D stochastic fields for %d realisations&#34;, nreal)
        return randfield.copy(&#34;A&#34;)

    def fieldgen3d_sva(
        self,
        # nnode: int,  # determined from ec.shape[0]
        ec: npt.ArrayLike,
        nc: npt.ArrayLike,
        zc: npt.ArrayLike,
        area: float | npt.ArrayLike,
        height: float | npt.ArrayLike,
        active: int | npt.ArrayLike,
        mean: float | npt.ArrayLike,
        var: float | npt.ArrayLike,
        ahmax: float | npt.ArrayLike,
        ahmin: float | npt.ArrayLike,
        avert: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        dip: float | npt.ArrayLike,
        rake: float | npt.ArrayLike,
        transtype: int | str | enum.TransType,
        avetype: int | str | enum.VarioType,
        power: float,
        # ldrand: int,  # same as nnode
        nreal: int,
    ) -&gt; npt.NDArray[np.float64]:
        &#34;&#34;&#34;
        Generate 3D stochastic fields based on a spatially varying variogram.

        Parameters
        ----------
        ec, nc, nz : array_like
            Model grid coordinates, each 1D array with shape (nnode,).
        area, height : float or array_like
            Areas and height of grid cells.
        active : int or array_like
            Inactive grid cells are equal to zero.
        mean : float or array_like
            Mean value of stochastic field.
        var : float or array_like
            Variance of stochastic field.
        ahmax, ahmin, avert : float or array_like
            Averaging function correlation lengths.
        bearing : float or array_like
            Bearing of ahmax direction.
        dip : float or array_like
            Dip of ahmax direction.
        rake : float or array_like
            Rotation of ahmin direction.
        transtype : int, str or enum.TransType
            Stochastic field pertains to natural(0) or log(1) properties.
        avetype : int, str or enum.VarioType
            Averaging function type, where 1:spher, 2:exp, 3:gauss, 4:pow.
        power : float
            Power used if avetype is 4 (pow).
        nreal : int
            Number of realisations to generate.

        Returns
        -------
        npt.NDArray[np.float64]
            Realisations with shape (nnode, nreal).
        &#34;&#34;&#34;
        node = ManyArrays(
            {&#34;ec&#34;: ec, &#34;nc&#34;: nc, &#34;zc&#34;: zc},
            {
                &#34;area&#34;: area,
                &#34;height&#34;: height,
                &#34;mean&#34;: mean,
                &#34;var&#34;: var,
                &#34;ahmax&#34;: ahmax,
                &#34;ahmin&#34;: ahmin,
                &#34;avert&#34;: avert,
                &#34;bearing&#34;: bearing,
                &#34;dip&#34;: dip,
                &#34;rake&#34;: rake,
            },
            {&#34;active&#34;: active},
        )
        if isinstance(transtype, str):
            transtype = enum.TransType.get_value(transtype)
        if isinstance(avetype, str):
            avetype = enum.VarioType.get_value(avetype)
        ldrand = nnode = len(node)
        randfield = np.zeros((ldrand, nreal), np.float64, order=&#34;F&#34;)
        res = self.pestutils.fieldgen3d_sva(
            byref(c_int(nnode)),
            node.ec,
            node.nc,
            node.zc,
            node.area,
            node.height,
            node.active,
            node.mean,
            node.var,
            node.ahmax,
            node.ahmin,
            node.avert,
            node.bearing,
            node.dip,
            node.rake,
            byref(c_int(transtype)),
            byref(c_int(avetype)),
            byref(c_double(power)),
            byref(c_int(ldrand)),
            byref(c_int(nreal)),
            randfield,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;generated 3D stochastic fields for %d realisations&#34;, nreal)
        return randfield.copy(&#34;A&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pypestutils.pestutilslib.PestUtilsLib"><code class="flex name class">
<span>class <span class="ident">PestUtilsLib</span></span>
<span>(</span><span>*, logger_level=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Mid-level Fortran-Python handler for pestutils library via ctypes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>logger_level</code></strong> :&ensp;<code>int, str</code>, default <code>20 (INFO)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PestUtilsLib:
    &#34;&#34;&#34;Mid-level Fortran-Python handler for pestutils library via ctypes.

    Parameters
    ----------
    logger_level : int, str, default 20 (INFO)
    &#34;&#34;&#34;

    def __init__(self, *, logger_level=logging.INFO) -&gt; None:
        from .ctypes_declarations import prototype
        from .finder import load
        from .logger import get_logger

        self.logger = get_logger(self.__class__.__name__, logger_level)
        self.pestutils = load()
        self.logger.debug(&#34;loaded %s&#34;, self.pestutils)
        prototype(self.pestutils)
        self.logger.debug(&#34;added prototypes&#34;)

    # def __del__(self):
    #    &#34;&#34;&#34;Clean-up library instance.&#34;&#34;&#34;
    #    try:
    #        self.free_all_memory()
    #    except (AttributeError, PestUtilsLibError) as err:
    #        if hasattr(self, &#34;logger&#34;):
    #            self.logger.warning(&#34;cannot call __del__: %s&#34;, err)

    def create_char_array(self, init: str | bytes, name: str):
        &#34;&#34;&#34;Create c_char Array with a fixed size from dimvar and intial value.

        Parameters
        ----------
        init : str or bytes
            Initial value.
        name : str
            Uppercase variable length name, e.g. LENFILENAME or LENVARTYPE.
        &#34;&#34;&#34;
        from .ctypes_declarations import get_dimvar_int

        if isinstance(init, str):
            init = init.encode()
        elif isinstance(init, bytes):
            pass
        else:
            raise TypeError(f&#34;expecting either str or bytes; found {type(init)}&#34;)
        size = get_dimvar_int(self.pestutils, name)
        if len(init) &gt; size:
            raise ValueError(f&#34;init size is {len(init)} but {name} is {size}&#34;)
        return create_string_buffer(init, size)

    def inquire_modflow_binary_file_specs(
        self,
        filein: str | PathLike,
        fileout: str | PathLike | None,
        isim: int,
        itype: int,
    ) -&gt; dict:
        &#34;&#34;&#34;Report some of the details of a MODFLOW-written binary file.

        Parameters
        ----------
        filein : str or PathLike
            MODFLOW-generated binary file to be read.
        fileout : str, PathLike, None
            Output file with with table of array headers. Use None or &#34;&#34; for
            no output file.
        isim : int
            Inform the function the simulator that generated the binary file:

             * 1 = traditional MODFLOW
             * 21 = MODFLOW-USG with structured grid
             * 22 = MODFLOW-USG with unstructured grid
             * 31 = MODFLOW 6 with DIS grid
             * 32 = MODFLOW 6 with DISV grid
             * 33 = MODFLOW 6 with DISU grid

        itype : int
            Where 1 = system state or dependent variable;
            2 = cell-by-cell flows.

        Returns
        -------
        iprec : int
            Where 1 = single; 2 = double.
        narray : int
            Number of arrays.
        ntime : int
            Number of times.
        &#34;&#34;&#34;
        filein = Path(filein)
        if not filein.is_file():
            raise FileNotFoundError(f&#34;could not find filein {filein}&#34;)
        if fileout:
            fileout = Path(fileout)
        else:
            fileout = b&#34;&#34;
        validate_scalar(&#34;isim&#34;, isim, isin=[1, 21, 22, 31, 32, 33])
        validate_scalar(&#34;itype&#34;, itype, isin=[1, 2])
        iprec = c_int()
        narray = c_int()
        ntime = c_int()
        res = self.pestutils.inquire_modflow_binary_file_specs(
            byref(self.create_char_array(bytes(filein), &#34;LENFILENAME&#34;)),
            byref(self.create_char_array(bytes(fileout), &#34;LENFILENAME&#34;)),
            byref(c_int(isim)),
            byref(c_int(itype)),
            byref(iprec),
            byref(narray),
            byref(ntime),
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;inquired modflow binary file specs from %r&#34;, filein.name)
        return {
            &#34;iprec&#34;: iprec.value,
            &#34;narray&#34;: narray.value,
            &#34;ntime&#34;: ntime.value,
        }

    def retrieve_error_message(self) -&gt; str:
        &#34;&#34;&#34;Retrieve error message from library.

        Returns
        -------
        str
        &#34;&#34;&#34;
        from .ctypes_declarations import get_char_array

        charray = get_char_array(self.pestutils, &#34;LENMESSAGE&#34;)()
        res = self.pestutils.retrieve_error_message(byref(charray))
        return charray[:res].rstrip(b&#34;\x00&#34;).decode()

    def install_structured_grid(
        self,
        gridname: str,
        ncol: int,
        nrow: int,
        nlay: int,
        icorner: int,
        e0: float,
        n0: float,
        rotation: float,
        delr: float | npt.ArrayLike,
        delc: float | npt.ArrayLike,
    ) -&gt; None:
        &#34;&#34;&#34;Install specifications for a structured grid.

        Parameters
        ----------
        gridname : str
            Unique non-blank grid name.
        ncol, nrow, nlay : int
            Grid dimensions.
        icorner : int
            Reference corner, use 1 for top left and 2 for bottom left.
        e0, n0 : float
            Reference offsets.
        rotation : float
            Grid rotation, counter-clockwise degrees.
        &#34;&#34;&#34;
        validate_scalar(&#34;ncol&#34;, ncol, gt=0)
        validate_scalar(&#34;nrow&#34;, nrow, gt=0)
        validate_scalar(&#34;nlay&#34;, nlay, gt=0)
        col = ManyArrays(float_any={&#34;delr&#34;: delr}, ar_len=ncol)
        row = ManyArrays(float_any={&#34;delc&#34;: delc}, ar_len=nrow)
        col.validate(&#34;delr&#34;, gt=0.0)
        row.validate(&#34;delc&#34;, gt=0.0)
        validate_scalar(&#34;icorner&#34;, icorner, isin=[1, 2])
        res = self.pestutils.install_structured_grid(
            byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
            byref(c_int(ncol)),
            byref(c_int(nrow)),
            byref(c_int(nlay)),
            byref(c_int(icorner)),
            byref(c_double(e0)),
            byref(c_double(n0)),
            byref(c_double(rotation)),
            col.delr,
            row.delc,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;installed structured grid %r from specs&#34;, gridname)

    def get_cell_centres_structured(self, gridname: str, ncpl: int) -&gt; tuple:
        &#34;&#34;&#34;Get cell centres of a single layer of an installed structured grid.

        Parameters
        ----------
        gridname : str
            Name of installed structured grid.
        ncpl : int
            Dimensions of grid (nrow x ncol).

        Returns
        -------
        cellx, cellx : npt.NDArray[np.float64]
            Coordinates of cell centres with dimensions (ncpl,).
        &#34;&#34;&#34;
        cellx = np.zeros(ncpl, np.float64, order=&#34;F&#34;)
        celly = np.zeros(ncpl, np.float64, order=&#34;F&#34;)
        res = self.pestutils.get_cell_centres_structured(
            byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
            byref(c_int(ncpl)),
            cellx,
            celly,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(
            &#34;evaluated %d cell centres from structured grid %r&#34;, ncpl, gridname
        )
        return cellx.copy(&#34;A&#34;), celly.copy(&#34;A&#34;)

    def uninstall_structured_grid(self, gridname: str) -&gt; None:
        &#34;&#34;&#34;Uninstall structured grid set by :meth:`install_structured_grid`.

        Parameters
        ----------
        gridname : str
            Unique non-blank grid name.
        &#34;&#34;&#34;
        res = self.pestutils.uninstall_structured_grid(
            byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;))
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;uninstalled structured grid %r&#34;, gridname)

    def free_all_memory(self) -&gt; None:
        &#34;&#34;&#34;Deallocate all memory that is being used.&#34;&#34;&#34;
        ret = self.pestutils.free_all_memory()
        if ret != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;all memory was freed up&#34;)

    def interp_from_structured_grid(
        self,
        gridname: str,
        depvarfile: str | PathLike,
        isim: int,
        iprec: int | str | enum.Prec,
        ntime: int,
        vartype: str,
        interpthresh: float,
        nointerpval: float,
        # npts: int,  # determined from layer.shape[0]
        ecoord: npt.ArrayLike,
        ncoord: npt.ArrayLike,
        layer: int | npt.ArrayLike,
    ) -&gt; dict:
        &#34;&#34;&#34;Spatial interpolate points from a structured grid.

        Parameters
        ----------
        gridname : str
            Name of installed structured grid.
        depvarfile : str or PathLike
            Name of binary file to read.
        isim : int
            Specify -1 for MT3D; 1 for MODFLOW.
        iprec : int, str or enum.Prec
            Specify 1 or &#34;single&#34;, 2 or &#34;double&#34;, or use enum.Prec.
        ntime : int
            Number of output times.
        vartype : str
            Only read arrays of this type.
        interpthresh : float
            Absolute threshold for dry or inactive.
        nointerpval : float
            Value to use where interpolation is not possible.
        ecoord, ncoord : array_like
            X/Y or Easting/Northing coordinates for points with shape (npts,).
        layer : int or array_like
            Layers of points with shape (npts,).

        Returns
        -------
        nproctime : int
            Number of processed simulation times.
        simtime : npt.NDArray[np.float64]
            Simulation times, with shape (ntime,).
        simstate : npt.NDArray[np.float64]
            Interpolated system states, with shape (ntime, npts).
        &#34;&#34;&#34;
        depvarfile = Path(depvarfile)
        if not depvarfile.is_file():
            raise FileNotFoundError(f&#34;could not find depvarfile {depvarfile}&#34;)
        if isinstance(iprec, str):
            iprec = enum.Prec.get_value(iprec)
        pta = ManyArrays({&#34;ecoord&#34;: ecoord, &#34;ncoord&#34;: ncoord}, int_any={&#34;layer&#34;: layer})
        npts = len(pta)
        simtime = np.zeros(ntime, np.float64, order=&#34;F&#34;)
        simstate = np.zeros((ntime, npts), np.float64, order=&#34;F&#34;)
        nproctime = c_int()
        res = self.pestutils.interp_from_structured_grid(
            byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
            byref(self.create_char_array(bytes(depvarfile), &#34;LENFILENAME&#34;)),
            byref(c_int(isim)),
            byref(c_int(iprec)),
            byref(c_int(ntime)),
            byref(self.create_char_array(vartype, &#34;LENVARTYPE&#34;)),
            byref(c_double(interpthresh)),
            byref(c_double(nointerpval)),
            byref(c_int(npts)),
            pta.ecoord,
            pta.ncoord,
            pta.layer,
            byref(nproctime),
            simtime,
            simstate,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(
            &#34;interpolated %d points from structured grid %r&#34;, npts, gridname
        )
        return {
            &#34;nproctime&#34;: nproctime.value,
            &#34;simtime&#34;: simtime.copy(&#34;A&#34;),
            &#34;simstate&#34;: simstate.copy(&#34;A&#34;),
        }

    def interp_to_obstime(
        self,
        # nsimtime: int,  # determined from simval.shape[0]
        nproctime: int,
        # npts: int,  # determined from simval.shape[1]
        simtime: npt.ArrayLike,
        simval: npt.ArrayLike,
        interpthresh: float,
        how_extrap: str,
        time_extrap: float,
        nointerpval: float,
        # nobs: int,  # determined from obspoint.shape[0]
        obspoint: npt.ArrayLike,
        obstime: npt.ArrayLike,
    ) -&gt; npt.NDArray[np.float64]:
        &#34;&#34;&#34;Temporal interpolation for simulation times to observed times.

        Parameters
        ----------
        nproctime : int
            Number of times featured in simtime and simval.
        simtime : array_like
            1D array of simulation times with shape (nsimtime,).
        simval : array_like
            2D array of simulated values with shape (nsimtime, npts).
        interpthresh : float
            Values equal or above this in simval have no meaning.
        how_extrap : str
            Method, where &#39;L&#39;=linear; &#39;C&#39;=constant.
        time_extrap : float
            Permitted extrapolation time.
        nointerpval : float
            Value to use where interpolation is not possible.
        obspoint : array_like
            1D integer array of indices of observation points,
            which start at 0 and -1 means no index. Shape is (nobs,).
        obstime : array_like
            1D array of observation times with shape (nobs,).

        Returns
        -------
        np.ndarray
            Time-interpolated simulation values with shape (nobs,).
        &#34;&#34;&#34;
        simtime = np.array(simtime, dtype=np.float64, order=&#34;F&#34;, copy=False)
        simval = np.array(simval, dtype=np.float64, order=&#34;F&#34;, copy=False)
        obspoint = np.array(obspoint, order=&#34;F&#34;, copy=False)
        obstime = np.array(obstime, dtype=np.float64, order=&#34;F&#34;, copy=False)
        if simtime.ndim != 1:
            raise ValueError(&#34;expected &#39;simtime&#39; to have ndim=1&#34;)
        elif simval.ndim != 2:
            raise ValueError(&#34;expected &#39;simval&#39; to have ndim=2&#34;)
        elif obspoint.ndim != 1:
            raise ValueError(&#34;expected &#39;obspoint&#39; to have ndim=1&#34;)
        elif obstime.ndim != 1:
            raise ValueError(&#34;expected &#39;obstime&#39; to have ndim=1&#34;)
        elif not np.issubdtype(obspoint.dtype, np.integer):
            raise ValueError(
                f&#34;expected &#39;obspoint&#39; to be integer type; found {obspoint.dtype}&#34;
            )
        nsimtime, npts = simval.shape
        nobs = len(obspoint)
        obssimval = np.zeros(nobs, np.float64, order=&#34;F&#34;)
        res = self.pestutils.interp_to_obstime(
            byref(c_int(nsimtime)),
            byref(c_int(nproctime)),
            byref(c_int(npts)),
            simtime,
            simval,
            byref(c_double(interpthresh)),
            byref(c_char(how_extrap.encode())),
            byref(c_double(time_extrap)),
            byref(c_double(nointerpval)),
            byref(c_int(nobs)),
            obspoint.astype(np.int32, copy=False),
            obstime,
            obssimval,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;interpolated %d time points to %d observations&#34;, npts, nobs)
        return obssimval.copy(&#34;A&#34;)

    def install_mf6_grid_from_file(
        self, gridname: str, grbfile: str | PathLike
    ) -&gt; dict:
        &#34;&#34;&#34;Install specifications for a MF6 grid from a GRB file.

        Parameters
        ----------
        gridname : str
            Unique non-blank grid name.
        grbfile : str or PathLike
            Path to a GRB binary grid file.

        Returns
        -------
        idis : int
            Where 1 is for DIS and 2 is for DISV.
        ncells : int
            Number of cells in the grid.
        ndim1, ndim2, ndim3 : int
            Grid dimensions.
        &#34;&#34;&#34;
        grbfile = Path(grbfile)
        if not grbfile.is_file():
            raise FileNotFoundError(f&#34;could not find grbfile {grbfile}&#34;)
        idis = c_int()
        ncells = c_int()
        ndim1 = c_int()
        ndim2 = c_int()
        ndim3 = c_int()
        res = self.pestutils.install_mf6_grid_from_file(
            byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
            byref(self.create_char_array(bytes(grbfile), &#34;LENFILENAME&#34;)),
            byref(idis),
            byref(ncells),
            byref(ndim1),
            byref(ndim2),
            byref(ndim3),
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(
            &#34;installed mf6 grid %r from grbfile=%r&#34;, gridname, grbfile.name
        )
        return {
            &#34;idis&#34;: idis.value,
            &#34;ncells&#34;: ncells.value,
            &#34;ndim1&#34;: ndim1.value,
            &#34;ndim2&#34;: ndim2.value,
            &#34;ndim3&#34;: ndim3.value,
        }

    def get_cell_centres_mf6(self, gridname: str, ncells: int) -&gt; tuple:
        &#34;&#34;&#34;Get cell centres from an installed MF6 grid.

        Parameters
        ----------
        gridname : str
            Name of installed MF6 grid.
        ncells : int
            Dimensions of grid.

        Returns
        -------
        cellx, cellx, cellz : npt.NDArray[np.float64]
            Coordinates of cell centres with dimensions (ncells,).
        &#34;&#34;&#34;
        cellx = np.zeros(ncells, np.float64, order=&#34;F&#34;)
        celly = np.zeros(ncells, np.float64, order=&#34;F&#34;)
        cellz = np.zeros(ncells, np.float64, order=&#34;F&#34;)
        res = self.pestutils.get_cell_centres_mf6(
            byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
            byref(c_int(ncells)),
            cellx,
            celly,
            cellz,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;evaluated %d cell centres from MF6 grid %r&#34;, ncells, gridname)
        return cellx.copy(&#34;A&#34;), celly.copy(&#34;A&#34;), cellz.copy(&#34;A&#34;)

    def uninstall_mf6_grid(self, gridname: str) -&gt; None:
        &#34;&#34;&#34;Uninstall MF6 grid set by :meth:`install_mf6_grid_from_file`.

        Parameters
        ----------
        gridname : str
            Unique non-blank grid name.
        &#34;&#34;&#34;
        res = self.pestutils.uninstall_mf6_grid(
            byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;))
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;uninstalled mf6 grid %r&#34;, gridname)

    def calc_mf6_interp_factors(
        self,
        gridname: str,
        # npts: int,  # determined from ecoord.shape[0]
        ecoord: npt.ArrayLike,
        ncoord: npt.ArrayLike,
        layer: int | npt.ArrayLike,
        factorfile: str | PathLike,
        factorfiletype: int | str | enum.FactorFileType,
        blnfile: str | PathLike,
    ) -&gt; npt.NDArray[np.int32]:
        &#34;&#34;&#34;Calculate interpolation factors from a MODFLOW 6 DIS or DISV.

        Parameters
        ----------
        gridname : str
            Unique non-blank grid name.
        ecoord, ncoord : array_like
            X/Y or Easting/Northing coordinates for points with shape (npts,).
        layer : int or array_like
            Layers of points with shape (npts,).
        factorfile : str or PathLike
            File for kriging factors to write.
        factorfiletype : int, str or enum.FactorFileType
            Factor file type, where 0:binary, 1:text.
        blnfile : str or PathLike
            Name of bln file to write.

        Returns
        -------
        npt.NDArray[np.int32]
            Array interp_success(npts), where 1 is success and 0 is failure.
        &#34;&#34;&#34;
        pta = ManyArrays({&#34;ecoord&#34;: ecoord, &#34;ncoord&#34;: ncoord}, int_any={&#34;layer&#34;: layer})
        npts = len(pta)
        factorfile = Path(factorfile)
        if isinstance(factorfiletype, str):
            factorfiletype = enum.FactorFileType.get_value(factorfiletype)
        blnfile = Path(blnfile)
        interp_success = np.zeros(npts, np.int32, order=&#34;F&#34;)
        res = self.pestutils.calc_mf6_interp_factors(
            byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
            byref(c_int(npts)),
            pta.ecoord,
            pta.ncoord,
            pta.layer,
            byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
            byref(c_int(factorfiletype)),
            byref(self.create_char_array(bytes(blnfile), &#34;LENFILENAME&#34;)),
            interp_success,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;calculated mf6 interp factors for %r&#34;, gridname)
        return interp_success.copy(&#34;A&#34;)

    def interp_from_mf6_depvar_file(
        self,
        depvarfile: str | PathLike,
        factorfile: str | PathLike,
        factorfiletype: int | str | enum.FactorFileType,
        ntime: int,
        vartype: str,
        interpthresh: float,
        reapportion: int | bool,
        nointerpval: float,
        npts: int,
    ) -&gt; dict:
        &#34;&#34;&#34;
        Interpolate points using previously-calculated interpolation factors.

        Parameters
        ----------
        depvarfile : str or PathLike
            Name of binary file to read.
        factorfile : str or PathLike
            File containing spatial interpolation factors, written by
            :meth:`calc_mf6_interp_factors`.
        factorfiletype : int, str or enum.FactorFileType
            Use 0 for binary; 1 for text.
        ntime : int
            Number of output times.
        vartype : str
            Only read arrays of this type.
        interpthresh : float
            Absolute threshold for dry or inactive.
        reapportion : int or bool
            Use 0 for no (False); 1 for yes (True).
        nointerpval : float
            Value to use where interpolation is not possible.
        npts : int
            Number of points for interpolation.

        Returns
        -------
        nproctime : int
            Number of processed simulation times.
        simtime : npt.NDArray[np.float64]
            Simulation times, with shape (ntime,).
        simstate : npt.NDArray[np.float64]
            Interpolated system states, with shape (ntime, npts).
        &#34;&#34;&#34;
        depvarfile = Path(depvarfile)
        if not depvarfile.is_file():
            raise FileNotFoundError(f&#34;could not find depvarfile {depvarfile}&#34;)
        factorfile = Path(factorfile)
        if not factorfile.is_file():
            raise FileNotFoundError(f&#34;could not find factorfile {factorfile}&#34;)
        if isinstance(factorfiletype, str):
            factorfiletype = enum.FactorFileType.get_value(factorfiletype)
        simtime = np.zeros(ntime, np.float64, order=&#34;F&#34;)
        simstate = np.zeros((ntime, npts), np.float64, order=&#34;F&#34;)
        nproctime = c_int()
        res = self.pestutils.interp_from_mf6_depvar_file(
            byref(self.create_char_array(bytes(depvarfile), &#34;LENFILENAME&#34;)),
            byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
            byref(c_int(factorfiletype)),
            byref(c_int(ntime)),
            byref(self.create_char_array(vartype, &#34;LENVARTYPE&#34;)),
            byref(c_double(interpthresh)),
            byref(c_int(reapportion)),
            byref(c_double(nointerpval)),
            byref(c_int(npts)),
            byref(nproctime),
            simtime,
            simstate,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(
            &#34;interpolated %d points from mf6 depvar file %r&#34;, npts, depvarfile.name
        )
        return {
            &#34;nproctime&#34;: nproctime.value,
            &#34;simtime&#34;: simtime.copy(&#34;A&#34;),
            &#34;simstate&#34;: simstate.copy(&#34;A&#34;),
        }

    def extract_flows_from_cbc_file(
        self,
        cbcfile: str | PathLike,
        flowtype: str,
        isim: int,
        iprec: int | str | enum.Prec,
        # ncell: int,  # from izone.shape[0]
        izone: npt.ArrayLike,
        nzone: int,
        ntime: int,
    ) -&gt; dict:
        &#34;&#34;&#34;
        Read and accumulates flows from a CBC flow file to a user-specified BC.

        Parameters
        ----------
        cbcfile : str | PathLike
            Cell-by-cell flow term file written by any MF version.
        flowtype : str
            Type of flow to read.
        isim : int
            Simulator type.
        iprec : int, str or enum.Prec
            Precision used to record real variables in cbc file.
        izone : array_like
            Zonation of model domain, with shape (ncell,).
        nzone : int
            Equals or exceeds number of zones; zone 0 doesn&#39;t count.
        ntime : int
            Equals or exceed number of model output times for flow type.

        Returns
        -------
        numzone : int
            Number of non-zero-valued zones.
        zonenumber : npt.NDArray[np.int32]
            Zone numbers, with shape (nzone,).
        nproctime : int
            Number of processed simulation times.
        timestep : npt.NDArray[np.int32]
            Simulation time step, with shape (ntime,).
        stressperiod : npt.NDArray[np.int32]
            Simulation stress period, with shape (ntime,).
        simtime : npt.NDArray[np.int32]
            Simulation time, with shape (ntime,).
            A time of -1.0 indicates unknown.
        simflow : npt.NDArray[np.int32]
            Interpolated flows, with shape (ntime, nzone).
        &#34;&#34;&#34;
        cbcfile = Path(cbcfile)
        if not cbcfile.is_file():
            raise FileNotFoundError(f&#34;could not find cbcfile {cbcfile}&#34;)
        validate_scalar(&#34;flowtype&#34;, flowtype, minlen=1)
        validate_scalar(&#34;iprec&#34;, iprec, enum=enum.Prec)
        if isinstance(iprec, str):
            iprec = enum.Prec.get_value(iprec)
        cell = ManyArrays(int_any={&#34;izone&#34;: izone})
        ncell = len(cell)
        numzone = c_int()
        zonenumber = np.zeros(nzone, np.int32, order=&#34;F&#34;)
        nproctime = c_int()
        timestep = np.zeros(ntime, np.int32, order=&#34;F&#34;)
        stressperiod = np.zeros(ntime, np.int32, order=&#34;F&#34;)
        simtime = np.zeros(ntime, np.float64, order=&#34;F&#34;)
        simflow = np.zeros((ntime, nzone), np.float64, order=&#34;F&#34;)
        res = self.pestutils.extract_flows_from_cbc_file(
            byref(self.create_char_array(bytes(cbcfile), &#34;LENFILENAME&#34;)),
            byref(self.create_char_array(flowtype, &#34;LENFLOWTYPE&#34;)),
            byref(c_int(isim)),
            byref(c_int(iprec)),
            byref(c_int(ncell)),
            cell.izone,
            byref(c_int(nzone)),
            byref(numzone),
            zonenumber,
            byref(c_int(ntime)),
            byref(nproctime),
            timestep,
            stressperiod,
            simtime,
            simflow,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;extracted flows from %r&#34;, cbcfile.name)
        return {
            &#34;numzone&#34;: numzone.value,
            &#34;zonenumber&#34;: zonenumber.copy(&#34;A&#34;),
            &#34;nproctime&#34;: nproctime.value,
            &#34;timestep&#34;: timestep.copy(&#34;A&#34;),
            &#34;stressperiod&#34;: stressperiod.copy(&#34;A&#34;),
            &#34;simtime&#34;: simtime.copy(&#34;A&#34;),
            &#34;simflow&#34;: simflow.copy(&#34;A&#34;),
        }

    def calc_kriging_factors_2d(
        self,
        # npts: int,  # determined from ecs.shape[0]
        ecs: npt.ArrayLike,
        ncs: npt.ArrayLike,
        zns: int | npt.ArrayLike,
        # mpts: int,  # determined from ect.shape[0]
        ect: npt.ArrayLike,
        nct: npt.ArrayLike,
        znt: int | npt.ArrayLike,
        vartype: int | str | enum.VarioType,
        krigtype: int | str | enum.KrigType,
        aa: float | npt.ArrayLike,
        anis: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        searchrad: float,
        maxpts: int,
        minpts: int,
        factorfile: str | PathLike,
        factorfiletype: int | str | enum.FactorFileType,
    ) -&gt; int:
        &#34;&#34;&#34;
        Calculate 2D kriging factors.

        Parameters
        ----------
        ecs, ncs : array_like
            Source point coordinates, each 1D array with shape (npts,).
        zns : int or array_like
            Source point zones, integer or 1D array with shape (npts,).
        ect, nct : array_like
            Target point coordinates, each 1D array with shape (mpts,).
        znt : int or array_like
            Target point zones, integer or 1D array with shape (mpts,).
        vartype : int, str or enum.VarioType
            Variogram type, where 1:spher, 2:exp, 3:gauss, 4:pow.
        krigtype : int, str, or enum.KrigType,
            Kriging type, where 0:simple, 1:ordinary.
        aa : float or array_like
            Variogram &#34;a&#34; value, float or 1D array with shape (mpts,).
        anis : float or array_like
            Variogram anisotropies, float or 1D array with shape (mpts,).
        bearing : float or array_like
            Variogram bearings, float or 1D array with shape (mpts,).
        searchrad : float
            Search radius.
        maxpts, minpts : int
            Search specifications.
        factorfile : str or PathLike
            File for kriging factors.
        factorfiletype : int, str or enum.FactorFileType
            Factor file type, where 0:binary, 1:text.

        Returns
        -------
        int
            Number of interp points.
        &#34;&#34;&#34;
        npta = ManyArrays({&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs}, int_any={&#34;zns&#34;: zns})
        npts = len(npta)
        mpta = ManyArrays(
            {&#34;ect&#34;: ect, &#34;nct&#34;: nct},
            {&#34;aa&#34;: aa, &#34;anis&#34;: anis, &#34;bearing&#34;: bearing},
            {&#34;znt&#34;: znt},
        )
        mpts = len(mpta)
        if isinstance(vartype, str):
            vartype = enum.VarioType.get_value(vartype)
        if isinstance(krigtype, str):
            krigtype = enum.KrigType.get_value(krigtype)
        factorfile = Path(factorfile)
        if isinstance(factorfiletype, str):
            factorfiletype = enum.FactorFileType.get_value(factorfiletype)
        icount_interp = c_int()
        res = self.pestutils.calc_kriging_factors_2d(
            byref(c_int(npts)),
            npta.ecs,
            npta.ncs,
            npta.zns,
            byref(c_int(mpts)),
            mpta.ect,
            mpta.nct,
            mpta.znt,
            byref(c_int(vartype)),
            byref(c_int(krigtype)),
            mpta.aa,
            mpta.anis,
            mpta.bearing,
            byref(c_double(searchrad)),
            byref(c_int(maxpts)),
            byref(c_int(minpts)),
            byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
            byref(c_int(factorfiletype)),
            byref(icount_interp),
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;calculated 2D kriging factors to %r&#34;, factorfile.name)
        return icount_interp.value

    def calc_kriging_factors_auto_2d(
        self,
        # npts: int,  # determined from ecs.shape[0]
        ecs: npt.ArrayLike,
        ncs: npt.ArrayLike,
        zns: int | npt.ArrayLike,
        # mpts: int,  # determined from ect.shape[0]
        ect: npt.ArrayLike,
        nct: npt.ArrayLike,
        znt: int | npt.ArrayLike,
        krigtype: int | str | enum.KrigType,
        anis: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        factorfile: str | PathLike,
        factorfiletype: int | str | enum.FactorFileType,
    ) -&gt; int:
        &#34;&#34;&#34;
        Calculate 2D kriging factors, with automatic variogram properties.

        Parameters
        ----------
        ecs, ncs : array_like
            Source point coordinates, each 1D array with shape (npts,).
        zns : int or array_like
            Source point zones, integer or 1D array with shape (npts,).
        ect, nct : array_like
            Target point coordinates, each 1D array with shape (mpts,).
        znt : int or array_like
            Target point zones, integer or 1D array with shape (mpts,).
        krigtype : int, str, enum.KrigType
            Kriging type, where 0:simple, 1:ordinary.
        anis : float or array_like
            Variogram anisotropies, float or 1D array with shape (mpts,).
        bearing : float or array_like
            Variogram bearings, float or 1D array with shape (mpts,).
        factorfile : str or PathLike
            File for kriging factors.
        factorfiletype : int, str or enum.FactorFileType
            Factor file type, where 0:binary, 1:text.

        Returns
        -------
        int
            Number of interp points.
        &#34;&#34;&#34;
        npta = ManyArrays({&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs}, int_any={&#34;zns&#34;: zns})
        npts = len(npta)
        mpta = ManyArrays(
            {&#34;ect&#34;: ect, &#34;nct&#34;: nct}, {&#34;anis&#34;: anis, &#34;bearing&#34;: bearing}, {&#34;znt&#34;: znt}
        )
        mpts = len(mpta)
        if isinstance(krigtype, str):
            krigtype = enum.KrigType.get_value(krigtype)
        factorfile = Path(factorfile)
        if isinstance(factorfiletype, str):
            factorfiletype = enum.FactorFileType.get_value(factorfiletype)
        icount_interp = c_int()
        res = self.pestutils.calc_kriging_factors_auto_2d(
            byref(c_int(npts)),
            npta.ecs,
            npta.ncs,
            npta.zns,
            byref(c_int(mpts)),
            mpta.ect,
            mpta.nct,
            mpta.znt,
            byref(c_int(krigtype)),
            mpta.anis,
            mpta.bearing,
            byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
            byref(c_int(factorfiletype)),
            byref(icount_interp),
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;calculated 2D auto kriging factors to %r&#34;, factorfile.name)
        return icount_interp.value

    def calc_kriging_factors_3d(
        self,
        # npts: int,  # determined from ecs.shape[0]
        ecs: npt.ArrayLike,
        ncs: npt.ArrayLike,
        zcs: npt.ArrayLike,
        zns: int | npt.ArrayLike,
        # mpts: int,  # determined from ect.shape[0]
        ect: npt.ArrayLike,
        nct: npt.ArrayLike,
        zct: npt.ArrayLike,
        znt: int | npt.ArrayLike,
        zonenum: int | npt.ArrayLike,
        krigtype: int | str | enum.KrigType,
        # nzone: int,  # determined from shape[0] from any zonenum..rake else 1
        vartype: int | str | enum.VarioType | npt.ArrayLike,
        ahmax: float | npt.ArrayLike,
        ahmin: float | npt.ArrayLike,
        avert: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        dip: float | npt.ArrayLike,
        rake: float | npt.ArrayLike,
        srhmax: float,
        srhmin: float,
        srvert: float,
        maxpts: int,
        minpts: int,
        factorfile: str | PathLike,
        factorfiletype: int | str | enum.FactorFileType,
    ) -&gt; int:
        &#34;&#34;&#34;
        Calculate 3D kriging factors.

        Parameters
        ----------
        ecs, ncs, zcs : array_like
            Source point coordinates, each 1D array with shape (npts,).
        zns : int or array_like
            Source point zones, integer or 1D array with shape (npts,).
        ect, nct, zct : array_like
            Target point coordinates, each 1D array with shape (mpts,).
        znt : int or array_like
            Target point zones, integer or 1D array with shape (mpts,).
        krigtype : int, str, or enum.KrigType,
            Kriging type, where 0:simple, 1:ordinary.
        zonenum : int, or array_like
            Zone numbers, inteter or 1D array with shape (nzone,).
        vartype : int, str, enum.VarioType or array_like
            Variogram type, where 1:spher, 2:exp, 3:gauss, 4:pow. If array,
            then it should have shape (nzone,).
        ahmax, ahmin, avert : float or array_like
            Variogram &#34;a&#34; values in 3 orthogonal directions (hmax, hmin, vert).
            Each can be a float or 1D array with shape (nzone,).
        bearing : float or array_like
            Bearing of hmax, float or 1D array with shape (nzone,).
        dip : float or array_like
            Dip of hmax, float or 1D array with shape (nzone,).
        rake : float or array_like
            Twist about hmax axis, float or 1D array with shape (nzone,).
        srhmax, srhmin, srvert : float
            Search radius in hmax, hmin, and vert directions.
        maxpts, minpts : int
            Search specifications.
        factorfile : str or PathLike
            File for kriging factors.
        factorfiletype : int, str or enum.FactorFileType
            Factor file type, where 0:binary, 1:text.

        Returns
        -------
        int
            Number of interp points.
        &#34;&#34;&#34;
        npta = ManyArrays({&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs, &#34;zcs&#34;: zcs}, int_any={&#34;zns&#34;: zns})
        npts = len(npta)
        mpta = ManyArrays({&#34;ect&#34;: ect, &#34;nct&#34;: nct, &#34;zct&#34;: zct}, int_any={&#34;znt&#34;: znt})
        mpts = len(mpta)
        if isinstance(krigtype, str):
            krigtype = enum.KrigType.get_value(krigtype)
        vartype = np.array(vartype)
        if np.issubdtype(vartype.dtype, str):
            vartype = np.vectorize(enum.VarioType.get_value)(vartype)
        if not np.issubdtype(vartype.dtype, np.integer):
            raise ValueError(&#34;expected &#39;vartype&#39; to be integer, str or enum.VarioType&#34;)
        nzone = ManyArrays(
            float_any={
                &#34;ahmax&#34;: ahmax,
                &#34;ahmin&#34;: ahmin,
                &#34;avert&#34;: avert,
                &#34;bearing&#34;: bearing,
                &#34;dip&#34;: dip,
                &#34;rake&#34;: rake,
            },
            int_any={&#34;zonenum&#34;: zonenum, &#34;vartype&#34;: vartype},
        )
        factorfile = Path(factorfile)
        if isinstance(factorfiletype, str):
            factorfiletype = enum.FactorFileType.get_value(factorfiletype)
        icount_interp = c_int()
        res = self.pestutils.calc_kriging_factors_3d(
            byref(c_int(npts)),
            npta.ecs,
            npta.ncs,
            npta.zcs,
            npta.zns,
            byref(c_int(mpts)),
            mpta.ect,
            mpta.nct,
            mpta.zct,
            mpta.znt,
            byref(c_int(krigtype)),
            byref(c_int(len(nzone))),
            nzone.zonenum,
            nzone.vartype,
            nzone.ahmax,
            nzone.ahmin,
            nzone.avert,
            nzone.bearing,
            nzone.dip,
            nzone.rake,
            byref(c_double(srhmax)),
            byref(c_double(srhmin)),
            byref(c_double(srvert)),
            byref(c_int(maxpts)),
            byref(c_int(minpts)),
            byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
            byref(c_int(factorfiletype)),
            byref(icount_interp),
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;calculated 3D kriging factors to %r&#34;, factorfile.name)
        return icount_interp.value

    def krige_using_file(
        self,
        factorfile: str | PathLike,
        factorfiletype: int | str | enum.FactorFileType,
        # npts: int,  # determined from sourceval.shape[0]
        mpts: int,
        krigtype: int | str | enum.KrigType,
        transtype: int | str | enum.TransType,
        sourceval: npt.ArrayLike,
        meanval: float | npt.ArrayLike | None,
        nointerpval: float,
    ) -&gt; dict:
        &#34;&#34;&#34;
        Apply interpolation factors calculated by other functions.

        Parameters
        ----------
        factorfile : str or PathLike
            Input file with kriging factors.
        factorfiletype : int, str or enum.FactorFileType
            Factor file type, where 0:binary, 1:text.
        mpts : int
            Number of target points, used to compare with value in factor file.
        krigtype : int, str, or enum.KrigType,
            Kriging type, where 0:simple, 1:ordinary.
        transtype : int, str, enum.TransType
            Tranformation type, where 0 is none and 1 is log.
        sourceval : array_like
            Values at sources, 1D array with shape (npts,).
        meanval : float, array_like, optional
            Mean values are required if simple kriging, described as a float
            or 1D array with shape (mpts,).
        nointerpval : float
            Value to use where interpolation is not possible.

        Returns
        -------
        targval : npt.NDArray[np.float64]
            Values calculated for targets.
        icount_interp : int
            Number of interpolation pts.
        &#34;&#34;&#34;
        factorfile = Path(factorfile)
        if not factorfile.is_file():
            raise FileNotFoundError(f&#34;could not find factorfile {factorfile}&#34;)
        if isinstance(factorfiletype, str):
            factorfiletype = enum.FactorFileType.get_value(factorfiletype)
        if isinstance(krigtype, str):
            krigtype = enum.KrigType.get_value(krigtype)
        if isinstance(transtype, str):
            transtype = enum.TransType.get_value(transtype)
        npta = ManyArrays({&#34;sourceval&#34;: sourceval})
        npts = len(npta)
        if meanval is None:
            if krigtype == enum.KrigType.simple:
                self.logger.error(
                    &#34;simple kriging requires &#39;meanval&#39;; assuming zero for now&#34;
                )
            meanval = 0.0
        mpta = ManyArrays(float_any={&#34;meanval&#34;: meanval}, ar_len=mpts)
        targval = np.full(mpts, nointerpval, dtype=np.float64, order=&#34;F&#34;)
        icount_interp = c_int()
        res = self.pestutils.krige_using_file(
            byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
            byref(c_int(factorfiletype)),
            byref(c_int(npts)),
            byref(c_int(mpts)),
            byref(c_int(krigtype)),
            byref(c_int(transtype)),
            npta.sourceval,
            targval,
            byref(icount_interp),
            mpta.meanval,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;kriged using factor file %r&#34;, factorfile.name)
        return {
            &#34;targval&#34;: targval.copy(&#34;A&#34;),
            &#34;icount_interp&#34;: icount_interp.value,
        }

    def build_covar_matrix_2d(
        self,
        # npts: int,  # determined from ec.shape[0]
        ec: npt.ArrayLike,
        nc: npt.ArrayLike,
        zn: int | npt.ArrayLike,
        vartype: int | str | enum.VarioType,
        nugget: float | npt.ArrayLike,
        aa: float | npt.ArrayLike,
        sill: float | npt.ArrayLike,
        anis: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        ldcovmat: int,
    ) -&gt; npt.NDArray[np.float64]:
        &#34;&#34;&#34;
        Calculate a covariance matrix for a set of 2D pilot points.

        Parameters
        ----------
        ec, nc : array_like
            Pilot point coordinates, each 1D array with shape (npts,).
        zn : int or array_like
            Pilot point zones, integer or 1D array with shape (npts,).
        vartype : int, str or enum.VarioType
            Variogram type, where 1:spher, 2:exp, 3:gauss, 4:pow.
        nugget, aa, sill, anis, bearing : float or array_like
            Variogram parameters, each float or 1D array with shape (npts,).
        ldcovmat : int
            Leading dimension of covmat.

        Returns
        -------
        npt.NDArray[np.float64]
            2D matrix covmat(ldcovmat, npts).
        &#34;&#34;&#34;
        pta = ManyArrays(
            {&#34;ec&#34;: ec, &#34;nc&#34;: nc},
            {
                &#34;nugget&#34;: nugget,
                &#34;aa&#34;: aa,
                &#34;sill&#34;: sill,
                &#34;anis&#34;: anis,
                &#34;bearing&#34;: bearing,
            },
            {&#34;zn&#34;: zn},
        )
        npts = len(pta)
        if isinstance(vartype, str):
            vartype = enum.VarioType.get_value(vartype)
        covmat = np.zeros((ldcovmat, npts), np.float64, order=&#34;F&#34;)
        res = self.pestutils.build_covar_matrix_2d(
            byref(c_int(npts)),
            pta.ec,
            pta.nc,
            pta.zn,
            byref(c_int(vartype)),
            pta.nugget,
            pta.aa,
            pta.sill,
            pta.anis,
            pta.bearing,
            byref(c_int(ldcovmat)),
            covmat,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;calculated covariance matrix for %d 2D pilot points&#34;, npts)
        return covmat.copy(&#34;A&#34;)

    def build_covar_matrix_3d(
        self,
        # npts: int,  # determined from ec.shape[0]
        ec: npt.ArrayLike,
        nc: npt.ArrayLike,
        zc: npt.ArrayLike,
        zn: int | npt.ArrayLike,
        vartype: int | str | enum.VarioType,
        nugget: float | npt.ArrayLike,
        sill: float | npt.ArrayLike,
        ahmax: float | npt.ArrayLike,
        ahmin: float | npt.ArrayLike,
        avert: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        dip: float | npt.ArrayLike,
        rake: float | npt.ArrayLike,
        ldcovmat: int,
    ) -&gt; npt.NDArray[np.float64]:
        &#34;&#34;&#34;
        Calculate a covariance matrix for a set of 3D pilot points.

        Parameters
        ----------
        ec, nc, zc: array_like
            Pilot point coordinates, each 1D array with shape (npts,).
        zn : int or array_like
            Pilot point zones, integer or 1D array with shape (npts,).
        vartype : int, str or enum.VarioType
            Variogram type, where 1:spher, 2:exp, 3:gauss, 4:pow.
        nugget, sill : float or array_like
            Variogram parameters, each float or 1D array with shape (npts,).
        ahmax, ahmin, avert : float or array_like
            Variogram a parameters, each float or 1D array with shape (npts,).
        bearing, dip, rake : float or array_like
            Variogram angles, each float or 1D array with shape (npts,).
        ldcovmat : int
            Leading dimension of covmat.

        Returns
        -------
        npt.NDArray[np.float64]
            2D matrix covmat(ldcovmat, npts).
        &#34;&#34;&#34;
        pta = ManyArrays(
            {&#34;ec&#34;: ec, &#34;nc&#34;: nc, &#34;zc&#34;: zc},
            {
                &#34;nugget&#34;: nugget,
                &#34;sill&#34;: sill,
                &#34;ahmax&#34;: ahmax,
                &#34;ahmin&#34;: ahmin,
                &#34;avert&#34;: avert,
                &#34;bearing&#34;: bearing,
                &#34;dip&#34;: dip,
                &#34;rake&#34;: rake,
            },
            {&#34;zn&#34;: zn},
        )
        npts = len(pta)
        if isinstance(vartype, str):
            vartype = enum.VarioType.get_value(vartype)
        covmat = np.zeros((ldcovmat, npts), np.float64, order=&#34;F&#34;)
        res = self.pestutils.build_covar_matrix_3d(
            byref(c_int(npts)),
            pta.ec,
            pta.nc,
            pta.zc,
            pta.zn,
            byref(c_int(vartype)),
            pta.nugget,
            pta.sill,
            pta.ahmax,
            pta.ahmin,
            pta.avert,
            pta.bearing,
            pta.dip,
            pta.rake,
            byref(c_int(ldcovmat)),
            covmat,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;calculated covariance matrix for %d 3D pilot points&#34;, npts)
        return covmat.copy(&#34;A&#34;)

    def calc_structural_overlay_factors(
        self,
        # npts: int,  # determined from ecs.shape[0]
        ecs: npt.ArrayLike,
        ncs: npt.ArrayLike,
        ids: int | npt.ArrayLike,
        conwidth: npt.ArrayLike,
        aa: npt.ArrayLike,
        structype: int | str | enum.StrucType,
        inverse_power: float,
        # mpts: int,  # determined from ect.shape[0]
        ect: npt.ArrayLike,
        nct: npt.ArrayLike,
        active: int | npt.ArrayLike,
        factorfile: str | PathLike,
        factorfiletype: int | str | enum.FactorFileType,
    ) -&gt; int:
        &#34;&#34;&#34;
        Calculate interpolation/blending factors for structural overlay parameters.

        Parameters
        ----------
        ecs, ncs : array_like
            Source point coordinates, each 1D array with shape (npts,).
        ids : int or array_like
            Source point structure number, integer or 1D array with shape (npts,).
        conwidth, aa : float or array_like
            Blending parameters, float or 1D array with shape (npts,).
        structype : int, str or enum.StrucType
            Structure type, where 0 is polylinear and 1 is polygonal.
        inverse_power : float
            Inverse power of distance.
        ect, nct : array_like
            Target point coordinates, each 1D array with shape (mpts,).
        active : int or array_like
            Target point activity, integer or 1D array with shape (mpts,).
        factorfile : str or PathLike
            File for kriging factors.
        factorfiletype : int, str or enum.FactorFileType
            Factor file type, where 0:binary, 1:text.

        Returns
        -------
        int
            Number of interp points.
        &#34;&#34;&#34;
        npta = ManyArrays(
            {&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs}, {&#34;conwidth&#34;: conwidth, &#34;aa&#34;: aa}, {&#34;ids&#34;: ids}
        )
        npts = len(npta)
        mpta = ManyArrays({&#34;ect&#34;: ect, &#34;nct&#34;: nct}, int_any={&#34;active&#34;: active})
        mpts = len(mpta)
        if isinstance(structype, str):
            structype = enum.StrucType.get_value(structype)
        factorfile = Path(factorfile)
        if isinstance(factorfiletype, str):
            factorfiletype = enum.FactorFileType.get_value(factorfiletype)
        icount_interp = c_int()
        res = self.pestutils.calc_structural_overlay_factors(
            byref(c_int(npts)),
            npta.ecs,
            npta.ncs,
            npta.ids,
            npta.conwidth,
            npta.aa,
            byref(c_int(structype)),
            byref(c_double(inverse_power)),
            byref(c_int(mpts)),
            mpta.ect,
            mpta.nct,
            mpta.active,
            byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
            byref(c_int(factorfiletype)),
            byref(icount_interp),
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(
            &#34;calculated interpolation/blending factors to %r&#34;, factorfile.name
        )
        return icount_interp.value

    def interpolate_blend_using_file(
        self,
        factorfile: str | PathLike,
        factorfiletype: int | str | enum.FactorFileType,
        # npts: int,  # determined from sourceval.shape[0]
        # mpts: int,  # determined from targval.shape[0]
        transtype: int | str | enum.TransType,
        lt_target: str | bool,
        gt_target: str | bool,
        sourceval: npt.ArrayLike,
        targval: npt.ArrayLike,
    ) -&gt; dict:
        &#34;&#34;&#34;
        Apply interpolation factors calculated by :meth:`calc_structural_overlay_factors`.

        Parameters
        ----------
        factorfile : str or PathLike
            File for kriging factors.
        factorfiletype : int, str or enum.FactorFileType
            Factor file type, where 0:binary, 1:text.
        transtype : int, str, enum.TransType
            Tranformation type, where 0 is none and 1 is log.
        lt_target, gt_target : str or bool
            Whether to undercut or exceed target, use &#34;Y&#34;/&#34;N&#34; or bool.
        sourceval : array_like
            Values at sources, 1D array with shape (npts,).
        targval : array_like
            Values at targets, 1D array with shape (mpts,).

        Returns
        -------
        targval : npt.NDArray[np.float64]
            Values calculated for targets.
        icount_interp : int
            Number of interpolation pts.
        &#34;&#34;&#34;
        factorfile = Path(factorfile)
        if not factorfile.is_file():
            raise FileNotFoundError(f&#34;could not find factorfile {factorfile}&#34;)
        if isinstance(factorfiletype, str):
            factorfiletype = enum.FactorFileType.get_value(factorfiletype)
        if isinstance(transtype, str):
            transtype = enum.TransType.get_value(transtype)
        if isinstance(lt_target, bool):
            lt_target = &#34;y&#34; if lt_target else &#34;n&#34;
        if isinstance(gt_target, bool):
            gt_target = &#34;y&#34; if gt_target else &#34;n&#34;
        npta = ManyArrays({&#34;sourceval&#34;: sourceval})
        npts = len(npta)
        mpta = ManyArrays({&#34;targval&#34;: targval})
        mpts = len(mpta)
        icount_interp = c_int()
        res = self.pestutils.interpolate_blend_using_file(
            byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
            byref(c_int(factorfiletype)),
            byref(c_int(npts)),
            byref(c_int(mpts)),
            byref(c_int(transtype)),
            byref(c_char(lt_target.encode())),
            byref(c_char(gt_target.encode())),
            npta.sourceval,
            mpta.targval,
            byref(icount_interp),
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;applied interpolation factors from %r&#34;, factorfile.name)
        return {
            &#34;targval&#34;: mpts.targval.copy(&#34;A&#34;),
            &#34;icount_interp&#34;: icount_interp.value,
        }

    def ipd_interpolate_2d(
        self,
        # npts: int,  # determined from ecs.shape[0]
        ecs: npt.ArrayLike,
        ncs: npt.ArrayLike,
        zns: int | npt.ArrayLike,
        sourceval: npt.ArrayLike,
        # mpts: int,  # determined from ect.shape[0]
        ect: npt.ArrayLike,
        nct: npt.ArrayLike,
        znt: int | npt.ArrayLike,
        transtype: int | str | enum.TransType,
        anis: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        invpow: float | npt.ArrayLike,
    ) -&gt; npt.NDArray[np.float64]:
        &#34;&#34;&#34;Undertake 2D inverse-power-of-distance spatial interpolation.

        Parameters
        ----------
        ecs, ncs : array_like
            Source point coordinates, each 1D array with shape (npts,).
        zns : int or array_like
            Source point zones, integer or 1D array with shape (npts,).
        sourceval : array_like
            Source values, 1D array with shape (npts,).
        ect, nct : array_like
            Target point coordinates, each 1D array with shape (mpts,).
        znt : int or array_like
            Target point zones, integer or 1D array with shape (mpts,).
        transtype : int, str, enum.TransType
            Tranformation type, where 0 is none and 1 is log.
        anis : float or array_like
            Local anisotropy, float or 1D array with shape (mpts,).
        bearing : float or array_like
            Local anisotropy bearing, float or 1D array with shape (mpts,).
        invpow : float or array_like
            Local inverse power of distance, float or 1D array with shape (mpts,).

        Returns
        -------
        npt.NDArray[np.float64]
            Values calculated for targets.
        &#34;&#34;&#34;
        npta = ManyArrays(
            {&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs, &#34;sourceval&#34;: sourceval}, int_any={&#34;zns&#34;: zns}
        )
        npts = len(npta)
        mpta = ManyArrays(
            {&#34;ect&#34;: ect, &#34;nct&#34;: nct},
            {&#34;anis&#34;: anis, &#34;bearing&#34;: bearing, &#34;invpow&#34;: invpow},
            {&#34;znt&#34;: znt},
        )
        mpts = len(mpta)
        if isinstance(transtype, str):
            transtype = enum.TransType.get_value(transtype)
        targval = np.zeros(mpts, np.float64, order=&#34;F&#34;)
        res = self.pestutils.ipd_interpolate_2d(
            byref(c_int(npts)),
            npta.ecs,
            npta.ncs,
            npta.zns,
            npta.sourceval,
            byref(c_int(mpts)),
            mpta.ect,
            mpta.nct,
            mpta.znt,
            targval,
            byref(c_int(transtype)),
            mpta.anis,
            mpta.bearing,
            mpta.invpow,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;undertook 2D inverse-power-of-distance spatial interpolation&#34;)
        return targval.copy(&#34;A&#34;)

    def ipd_interpolate_3d(
        self,
        # npts: int,  # determined from ecs.shape[0]
        ecs: npt.ArrayLike,
        ncs: npt.ArrayLike,
        zcs: npt.ArrayLike,
        zns: int | npt.ArrayLike,
        sourceval: npt.ArrayLike,
        # mpts: int,  # determined from ect.shape[0]
        ect: npt.ArrayLike,
        nct: npt.ArrayLike,
        zct: npt.ArrayLike,
        znt: int | npt.ArrayLike,
        transtype: int | str | enum.TransType,
        ahmax: float | npt.ArrayLike,
        ahmin: float | npt.ArrayLike,
        avert: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        dip: float | npt.ArrayLike,
        rake: float | npt.ArrayLike,
        invpow: float | npt.ArrayLike,
    ) -&gt; npt.NDArray[np.float64]:
        &#34;&#34;&#34;Undertake 3D inverse-power-of-distance spatial interpolation.

        Parameters
        ----------
        ecs, ncs, zcs : array_like
            Source point coordinates, each 1D array with shape (npts,).
        zns : int or array_like
            Source point zones, integer or 1D array with shape (npts,).
        sourceval : array_like
            Source values, 1D array with shape (npts,).
        ect, nct, zct : array_like
            Target point coordinates, each 1D array with shape (mpts,).
        znt : int or array_like
            Target point zones, integer or 1D array with shape (mpts,).
        transtype : int, str, enum.TransType
            Tranformation type, where 0 is none and 1 is log.
        ahmax, ahmin, avert : float or array_like
            Relative correlation lengths, float or 1D array with shape (mpts,).
        bearing, dip, rake : float or array_like
            Correlation directions, float or 1D array with shape (mpts,).
        invpow : float or array_like
            Local inverse power of distance, float or 1D array with shape (mpts,).

        Returns
        -------
        npt.NDArray[np.float64]
            Values calculated for targets.
        &#34;&#34;&#34;
        npta = ManyArrays(
            {&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs, &#34;zcs&#34;: zcs, &#34;sourceval&#34;: sourceval},
            int_any={&#34;zns&#34;: zns},
        )
        npts = len(npta)
        mpta = ManyArrays(
            {&#34;ect&#34;: ect, &#34;nct&#34;: nct, &#34;zct&#34;: zct},
            {
                &#34;ahmax&#34;: ahmax,
                &#34;ahmin&#34;: ahmin,
                &#34;avert&#34;: avert,
                &#34;bearing&#34;: bearing,
                &#34;dip&#34;: dip,
                &#34;rake&#34;: rake,
                &#34;invpow&#34;: invpow,
            },
            {&#34;znt&#34;: znt},
        )
        mpts = len(mpta)
        if isinstance(transtype, str):
            transtype = enum.TransType.get_value(transtype)
        targval = np.zeros(mpts, np.float64, order=&#34;F&#34;)
        res = self.pestutils.ipd_interpolate_3d(
            byref(c_int(npts)),
            npta.ecs,
            npta.ncs,
            npta.zcs,
            npta.zns,
            npta.sourceval,
            byref(c_int(mpts)),
            mpta.ect,
            mpta.nct,
            mpta.zct,
            mpta.znt,
            targval,
            byref(c_int(transtype)),
            mpta.ahmax,
            mpta.ahmin,
            mpta.avert,
            mpta.bearing,
            mpta.dip,
            mpta.rake,
            mpta.invpow,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;undertook 3D inverse-power-of-distance spatial interpolation&#34;)
        return targval.copy(&#34;A&#34;)

    def initialize_randgen(self, iseed: int) -&gt; None:
        &#34;&#34;&#34;
        Initialize the random number generator.

        Parameters
        ----------
        iseed : int
            Seed value.
        &#34;&#34;&#34;
        res = self.pestutils.initialize_randgen(byref(c_int(iseed)))
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;initialized the random number generator&#34;)

    def fieldgen2d_sva(
        self,
        # nnode: int,  # determined from ec.shape[0]
        ec: npt.ArrayLike,
        nc: npt.ArrayLike,
        area: float | npt.ArrayLike,
        active: int | npt.ArrayLike,
        mean: float | npt.ArrayLike,
        var: float | npt.ArrayLike,
        aa: float | npt.ArrayLike,
        anis: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        transtype: int | str | enum.TransType,
        avetype: int | str | enum.VarioType,
        power: float,
        # ldrand: int,  # same as nnode
        nreal: int,
    ) -&gt; npt.NDArray[np.float64]:
        &#34;&#34;&#34;
        Generate 2D stochastic fields based on a spatially varying variogram.

        Parameters
        ----------
        ec, nc : array_like
            Model grid coordinates, each 1D array with shape (nnode,).
        area : float or array_like
            Areas of grid cells.
        active : int or array_like
            Inactive grid cells are equal to zero.
        mean : float or array_like
            Mean value of stochastic field.
        var : float or array_like
            Variance of stochastic field.
        aa : float or array_like
            Averaging function spatial dimension.
        anis : float or array_like
            Anisotropy ratio.
        bearing : float or array_like
            Bearing of principal anisotropy axis.
        transtype : int, str or enum.TransType
            Stochastic field pertains to natural(0) or log(1) properties.
        avetype : int, str or enum.VarioType
            Averaging function type, where 1:spher, 2:exp, 3:gauss, 4:pow.
        power : float
            Power used if avetype is 4 (pow).
        nreal : int
            Number of realisations to generate.

        Returns
        -------
        npt.NDArray[np.float64]
            Realisations with shape (nnode, nreal).
        &#34;&#34;&#34;
        node = ManyArrays(
            {&#34;ec&#34;: ec, &#34;nc&#34;: nc},
            {
                &#34;area&#34;: area,
                &#34;mean&#34;: mean,
                &#34;var&#34;: var,
                &#34;aa&#34;: aa,
                &#34;anis&#34;: anis,
                &#34;bearing&#34;: bearing,
            },
            {&#34;active&#34;: active},
        )
        if isinstance(transtype, str):
            transtype = enum.TransType.get_value(transtype)
        if isinstance(avetype, str):
            avetype = enum.VarioType.get_value(avetype)
        ldrand = nnode = len(node)
        randfield = np.zeros((ldrand, nreal), np.float64, order=&#34;F&#34;)
        res = self.pestutils.fieldgen2d_sva(
            byref(c_int(nnode)),
            node.ec,
            node.nc,
            node.area,
            node.active,
            node.mean,
            node.var,
            node.aa,
            node.anis,
            node.bearing,
            byref(c_int(transtype)),
            byref(c_int(avetype)),
            byref(c_double(power)),
            byref(c_int(ldrand)),
            byref(c_int(nreal)),
            randfield,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;generated 2D stochastic fields for %d realisations&#34;, nreal)
        return randfield.copy(&#34;A&#34;)

    def fieldgen3d_sva(
        self,
        # nnode: int,  # determined from ec.shape[0]
        ec: npt.ArrayLike,
        nc: npt.ArrayLike,
        zc: npt.ArrayLike,
        area: float | npt.ArrayLike,
        height: float | npt.ArrayLike,
        active: int | npt.ArrayLike,
        mean: float | npt.ArrayLike,
        var: float | npt.ArrayLike,
        ahmax: float | npt.ArrayLike,
        ahmin: float | npt.ArrayLike,
        avert: float | npt.ArrayLike,
        bearing: float | npt.ArrayLike,
        dip: float | npt.ArrayLike,
        rake: float | npt.ArrayLike,
        transtype: int | str | enum.TransType,
        avetype: int | str | enum.VarioType,
        power: float,
        # ldrand: int,  # same as nnode
        nreal: int,
    ) -&gt; npt.NDArray[np.float64]:
        &#34;&#34;&#34;
        Generate 3D stochastic fields based on a spatially varying variogram.

        Parameters
        ----------
        ec, nc, nz : array_like
            Model grid coordinates, each 1D array with shape (nnode,).
        area, height : float or array_like
            Areas and height of grid cells.
        active : int or array_like
            Inactive grid cells are equal to zero.
        mean : float or array_like
            Mean value of stochastic field.
        var : float or array_like
            Variance of stochastic field.
        ahmax, ahmin, avert : float or array_like
            Averaging function correlation lengths.
        bearing : float or array_like
            Bearing of ahmax direction.
        dip : float or array_like
            Dip of ahmax direction.
        rake : float or array_like
            Rotation of ahmin direction.
        transtype : int, str or enum.TransType
            Stochastic field pertains to natural(0) or log(1) properties.
        avetype : int, str or enum.VarioType
            Averaging function type, where 1:spher, 2:exp, 3:gauss, 4:pow.
        power : float
            Power used if avetype is 4 (pow).
        nreal : int
            Number of realisations to generate.

        Returns
        -------
        npt.NDArray[np.float64]
            Realisations with shape (nnode, nreal).
        &#34;&#34;&#34;
        node = ManyArrays(
            {&#34;ec&#34;: ec, &#34;nc&#34;: nc, &#34;zc&#34;: zc},
            {
                &#34;area&#34;: area,
                &#34;height&#34;: height,
                &#34;mean&#34;: mean,
                &#34;var&#34;: var,
                &#34;ahmax&#34;: ahmax,
                &#34;ahmin&#34;: ahmin,
                &#34;avert&#34;: avert,
                &#34;bearing&#34;: bearing,
                &#34;dip&#34;: dip,
                &#34;rake&#34;: rake,
            },
            {&#34;active&#34;: active},
        )
        if isinstance(transtype, str):
            transtype = enum.TransType.get_value(transtype)
        if isinstance(avetype, str):
            avetype = enum.VarioType.get_value(avetype)
        ldrand = nnode = len(node)
        randfield = np.zeros((ldrand, nreal), np.float64, order=&#34;F&#34;)
        res = self.pestutils.fieldgen3d_sva(
            byref(c_int(nnode)),
            node.ec,
            node.nc,
            node.zc,
            node.area,
            node.height,
            node.active,
            node.mean,
            node.var,
            node.ahmax,
            node.ahmin,
            node.avert,
            node.bearing,
            node.dip,
            node.rake,
            byref(c_int(transtype)),
            byref(c_int(avetype)),
            byref(c_double(power)),
            byref(c_int(ldrand)),
            byref(c_int(nreal)),
            randfield,
        )
        if res != 0:
            raise PestUtilsLibError(self.retrieve_error_message())
        self.logger.info(&#34;generated 3D stochastic fields for %d realisations&#34;, nreal)
        return randfield.copy(&#34;A&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pypestutils.pestutilslib.PestUtilsLib.build_covar_matrix_2d"><code class="name flex">
<span>def <span class="ident">build_covar_matrix_2d</span></span>(<span>self, ec:npt.ArrayLike, nc:npt.ArrayLike, zn:int|npt.ArrayLike, vartype:int|str|enum.VarioType, nugget:float|npt.ArrayLike, aa:float|npt.ArrayLike, sill:float|npt.ArrayLike, anis:float|npt.ArrayLike, bearing:float|npt.ArrayLike, ldcovmat:int) >numpy.ndarray[typing.Any,numpy.dtype[numpy.float64]]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a covariance matrix for a set of 2D pilot points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ec</code></strong>, <strong><code>nc</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Pilot point coordinates, each 1D array with shape (npts,).</dd>
<dt><strong><code>zn</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Pilot point zones, integer or 1D array with shape (npts,).</dd>
<dt><strong><code>vartype</code></strong> :&ensp;<code>int, str</code> or <code>enum.VarioType</code></dt>
<dd>Variogram type, where 1:spher, 2:exp, 3:gauss, 4:pow.</dd>
<dt><strong><code>nugget</code></strong>, <strong><code>aa</code></strong>, <strong><code>sill</code></strong>, <strong><code>anis</code></strong>, <strong><code>bearing</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Variogram parameters, each float or 1D array with shape (npts,).</dd>
<dt><strong><code>ldcovmat</code></strong> :&ensp;<code>int</code></dt>
<dd>Leading dimension of covmat.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>npt.NDArray[np.float64]</code></dt>
<dd>2D matrix covmat(ldcovmat, npts).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_covar_matrix_2d(
    self,
    # npts: int,  # determined from ec.shape[0]
    ec: npt.ArrayLike,
    nc: npt.ArrayLike,
    zn: int | npt.ArrayLike,
    vartype: int | str | enum.VarioType,
    nugget: float | npt.ArrayLike,
    aa: float | npt.ArrayLike,
    sill: float | npt.ArrayLike,
    anis: float | npt.ArrayLike,
    bearing: float | npt.ArrayLike,
    ldcovmat: int,
) -&gt; npt.NDArray[np.float64]:
    &#34;&#34;&#34;
    Calculate a covariance matrix for a set of 2D pilot points.

    Parameters
    ----------
    ec, nc : array_like
        Pilot point coordinates, each 1D array with shape (npts,).
    zn : int or array_like
        Pilot point zones, integer or 1D array with shape (npts,).
    vartype : int, str or enum.VarioType
        Variogram type, where 1:spher, 2:exp, 3:gauss, 4:pow.
    nugget, aa, sill, anis, bearing : float or array_like
        Variogram parameters, each float or 1D array with shape (npts,).
    ldcovmat : int
        Leading dimension of covmat.

    Returns
    -------
    npt.NDArray[np.float64]
        2D matrix covmat(ldcovmat, npts).
    &#34;&#34;&#34;
    pta = ManyArrays(
        {&#34;ec&#34;: ec, &#34;nc&#34;: nc},
        {
            &#34;nugget&#34;: nugget,
            &#34;aa&#34;: aa,
            &#34;sill&#34;: sill,
            &#34;anis&#34;: anis,
            &#34;bearing&#34;: bearing,
        },
        {&#34;zn&#34;: zn},
    )
    npts = len(pta)
    if isinstance(vartype, str):
        vartype = enum.VarioType.get_value(vartype)
    covmat = np.zeros((ldcovmat, npts), np.float64, order=&#34;F&#34;)
    res = self.pestutils.build_covar_matrix_2d(
        byref(c_int(npts)),
        pta.ec,
        pta.nc,
        pta.zn,
        byref(c_int(vartype)),
        pta.nugget,
        pta.aa,
        pta.sill,
        pta.anis,
        pta.bearing,
        byref(c_int(ldcovmat)),
        covmat,
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;calculated covariance matrix for %d 2D pilot points&#34;, npts)
    return covmat.copy(&#34;A&#34;)</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.build_covar_matrix_3d"><code class="name flex">
<span>def <span class="ident">build_covar_matrix_3d</span></span>(<span>self, ec:npt.ArrayLike, nc:npt.ArrayLike, zc:npt.ArrayLike, zn:int|npt.ArrayLike, vartype:int|str|enum.VarioType, nugget:float|npt.ArrayLike, sill:float|npt.ArrayLike, ahmax:float|npt.ArrayLike, ahmin:float|npt.ArrayLike, avert:float|npt.ArrayLike, bearing:float|npt.ArrayLike, dip:float|npt.ArrayLike, rake:float|npt.ArrayLike, ldcovmat:int) >numpy.ndarray[typing.Any,numpy.dtype[numpy.float64]]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a covariance matrix for a set of 3D pilot points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ec</code></strong>, <strong><code>nc</code></strong>, <strong><code>zc</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Pilot point coordinates, each 1D array with shape (npts,).</dd>
<dt><strong><code>zn</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Pilot point zones, integer or 1D array with shape (npts,).</dd>
<dt><strong><code>vartype</code></strong> :&ensp;<code>int, str</code> or <code>enum.VarioType</code></dt>
<dd>Variogram type, where 1:spher, 2:exp, 3:gauss, 4:pow.</dd>
<dt><strong><code>nugget</code></strong>, <strong><code>sill</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Variogram parameters, each float or 1D array with shape (npts,).</dd>
<dt><strong><code>ahmax</code></strong>, <strong><code>ahmin</code></strong>, <strong><code>avert</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Variogram a parameters, each float or 1D array with shape (npts,).</dd>
<dt><strong><code>bearing</code></strong>, <strong><code>dip</code></strong>, <strong><code>rake</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Variogram angles, each float or 1D array with shape (npts,).</dd>
<dt><strong><code>ldcovmat</code></strong> :&ensp;<code>int</code></dt>
<dd>Leading dimension of covmat.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>npt.NDArray[np.float64]</code></dt>
<dd>2D matrix covmat(ldcovmat, npts).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_covar_matrix_3d(
    self,
    # npts: int,  # determined from ec.shape[0]
    ec: npt.ArrayLike,
    nc: npt.ArrayLike,
    zc: npt.ArrayLike,
    zn: int | npt.ArrayLike,
    vartype: int | str | enum.VarioType,
    nugget: float | npt.ArrayLike,
    sill: float | npt.ArrayLike,
    ahmax: float | npt.ArrayLike,
    ahmin: float | npt.ArrayLike,
    avert: float | npt.ArrayLike,
    bearing: float | npt.ArrayLike,
    dip: float | npt.ArrayLike,
    rake: float | npt.ArrayLike,
    ldcovmat: int,
) -&gt; npt.NDArray[np.float64]:
    &#34;&#34;&#34;
    Calculate a covariance matrix for a set of 3D pilot points.

    Parameters
    ----------
    ec, nc, zc: array_like
        Pilot point coordinates, each 1D array with shape (npts,).
    zn : int or array_like
        Pilot point zones, integer or 1D array with shape (npts,).
    vartype : int, str or enum.VarioType
        Variogram type, where 1:spher, 2:exp, 3:gauss, 4:pow.
    nugget, sill : float or array_like
        Variogram parameters, each float or 1D array with shape (npts,).
    ahmax, ahmin, avert : float or array_like
        Variogram a parameters, each float or 1D array with shape (npts,).
    bearing, dip, rake : float or array_like
        Variogram angles, each float or 1D array with shape (npts,).
    ldcovmat : int
        Leading dimension of covmat.

    Returns
    -------
    npt.NDArray[np.float64]
        2D matrix covmat(ldcovmat, npts).
    &#34;&#34;&#34;
    pta = ManyArrays(
        {&#34;ec&#34;: ec, &#34;nc&#34;: nc, &#34;zc&#34;: zc},
        {
            &#34;nugget&#34;: nugget,
            &#34;sill&#34;: sill,
            &#34;ahmax&#34;: ahmax,
            &#34;ahmin&#34;: ahmin,
            &#34;avert&#34;: avert,
            &#34;bearing&#34;: bearing,
            &#34;dip&#34;: dip,
            &#34;rake&#34;: rake,
        },
        {&#34;zn&#34;: zn},
    )
    npts = len(pta)
    if isinstance(vartype, str):
        vartype = enum.VarioType.get_value(vartype)
    covmat = np.zeros((ldcovmat, npts), np.float64, order=&#34;F&#34;)
    res = self.pestutils.build_covar_matrix_3d(
        byref(c_int(npts)),
        pta.ec,
        pta.nc,
        pta.zc,
        pta.zn,
        byref(c_int(vartype)),
        pta.nugget,
        pta.sill,
        pta.ahmax,
        pta.ahmin,
        pta.avert,
        pta.bearing,
        pta.dip,
        pta.rake,
        byref(c_int(ldcovmat)),
        covmat,
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;calculated covariance matrix for %d 3D pilot points&#34;, npts)
    return covmat.copy(&#34;A&#34;)</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.calc_kriging_factors_2d"><code class="name flex">
<span>def <span class="ident">calc_kriging_factors_2d</span></span>(<span>self, ecs:npt.ArrayLike, ncs:npt.ArrayLike, zns:int|npt.ArrayLike, ect:npt.ArrayLike, nct:npt.ArrayLike, znt:int|npt.ArrayLike, vartype:int|str|enum.VarioType, krigtype:int|str|enum.KrigType, aa:float|npt.ArrayLike, anis:float|npt.ArrayLike, bearing:float|npt.ArrayLike, searchrad:float, maxpts:int, minpts:int, factorfile:str|PathLike, factorfiletype:int|str|enum.FactorFileType) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate 2D kriging factors.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ecs</code></strong>, <strong><code>ncs</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Source point coordinates, each 1D array with shape (npts,).</dd>
<dt><strong><code>zns</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Source point zones, integer or 1D array with shape (npts,).</dd>
<dt><strong><code>ect</code></strong>, <strong><code>nct</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Target point coordinates, each 1D array with shape (mpts,).</dd>
<dt><strong><code>znt</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Target point zones, integer or 1D array with shape (mpts,).</dd>
<dt><strong><code>vartype</code></strong> :&ensp;<code>int, str</code> or <code>enum.VarioType</code></dt>
<dd>Variogram type, where 1:spher, 2:exp, 3:gauss, 4:pow.</dd>
<dt><strong><code>krigtype</code></strong> :&ensp;<code>int, str,</code> or <code>enum.KrigType,</code></dt>
<dd>Kriging type, where 0:simple, 1:ordinary.</dd>
<dt><strong><code>aa</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Variogram "a" value, float or 1D array with shape (mpts,).</dd>
<dt><strong><code>anis</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Variogram anisotropies, float or 1D array with shape (mpts,).</dd>
<dt><strong><code>bearing</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Variogram bearings, float or 1D array with shape (mpts,).</dd>
<dt><strong><code>searchrad</code></strong> :&ensp;<code>float</code></dt>
<dd>Search radius.</dd>
<dt><strong><code>maxpts</code></strong>, <strong><code>minpts</code></strong> :&ensp;<code>int</code></dt>
<dd>Search specifications.</dd>
<dt><strong><code>factorfile</code></strong> :&ensp;<code>str</code> or <code>PathLike</code></dt>
<dd>File for kriging factors.</dd>
<dt><strong><code>factorfiletype</code></strong> :&ensp;<code>int, str</code> or <code>enum.FactorFileType</code></dt>
<dd>Factor file type, where 0:binary, 1:text.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Number of interp points.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_kriging_factors_2d(
    self,
    # npts: int,  # determined from ecs.shape[0]
    ecs: npt.ArrayLike,
    ncs: npt.ArrayLike,
    zns: int | npt.ArrayLike,
    # mpts: int,  # determined from ect.shape[0]
    ect: npt.ArrayLike,
    nct: npt.ArrayLike,
    znt: int | npt.ArrayLike,
    vartype: int | str | enum.VarioType,
    krigtype: int | str | enum.KrigType,
    aa: float | npt.ArrayLike,
    anis: float | npt.ArrayLike,
    bearing: float | npt.ArrayLike,
    searchrad: float,
    maxpts: int,
    minpts: int,
    factorfile: str | PathLike,
    factorfiletype: int | str | enum.FactorFileType,
) -&gt; int:
    &#34;&#34;&#34;
    Calculate 2D kriging factors.

    Parameters
    ----------
    ecs, ncs : array_like
        Source point coordinates, each 1D array with shape (npts,).
    zns : int or array_like
        Source point zones, integer or 1D array with shape (npts,).
    ect, nct : array_like
        Target point coordinates, each 1D array with shape (mpts,).
    znt : int or array_like
        Target point zones, integer or 1D array with shape (mpts,).
    vartype : int, str or enum.VarioType
        Variogram type, where 1:spher, 2:exp, 3:gauss, 4:pow.
    krigtype : int, str, or enum.KrigType,
        Kriging type, where 0:simple, 1:ordinary.
    aa : float or array_like
        Variogram &#34;a&#34; value, float or 1D array with shape (mpts,).
    anis : float or array_like
        Variogram anisotropies, float or 1D array with shape (mpts,).
    bearing : float or array_like
        Variogram bearings, float or 1D array with shape (mpts,).
    searchrad : float
        Search radius.
    maxpts, minpts : int
        Search specifications.
    factorfile : str or PathLike
        File for kriging factors.
    factorfiletype : int, str or enum.FactorFileType
        Factor file type, where 0:binary, 1:text.

    Returns
    -------
    int
        Number of interp points.
    &#34;&#34;&#34;
    npta = ManyArrays({&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs}, int_any={&#34;zns&#34;: zns})
    npts = len(npta)
    mpta = ManyArrays(
        {&#34;ect&#34;: ect, &#34;nct&#34;: nct},
        {&#34;aa&#34;: aa, &#34;anis&#34;: anis, &#34;bearing&#34;: bearing},
        {&#34;znt&#34;: znt},
    )
    mpts = len(mpta)
    if isinstance(vartype, str):
        vartype = enum.VarioType.get_value(vartype)
    if isinstance(krigtype, str):
        krigtype = enum.KrigType.get_value(krigtype)
    factorfile = Path(factorfile)
    if isinstance(factorfiletype, str):
        factorfiletype = enum.FactorFileType.get_value(factorfiletype)
    icount_interp = c_int()
    res = self.pestutils.calc_kriging_factors_2d(
        byref(c_int(npts)),
        npta.ecs,
        npta.ncs,
        npta.zns,
        byref(c_int(mpts)),
        mpta.ect,
        mpta.nct,
        mpta.znt,
        byref(c_int(vartype)),
        byref(c_int(krigtype)),
        mpta.aa,
        mpta.anis,
        mpta.bearing,
        byref(c_double(searchrad)),
        byref(c_int(maxpts)),
        byref(c_int(minpts)),
        byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
        byref(c_int(factorfiletype)),
        byref(icount_interp),
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;calculated 2D kriging factors to %r&#34;, factorfile.name)
    return icount_interp.value</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.calc_kriging_factors_3d"><code class="name flex">
<span>def <span class="ident">calc_kriging_factors_3d</span></span>(<span>self, ecs:npt.ArrayLike, ncs:npt.ArrayLike, zcs:npt.ArrayLike, zns:int|npt.ArrayLike, ect:npt.ArrayLike, nct:npt.ArrayLike, zct:npt.ArrayLike, znt:int|npt.ArrayLike, zonenum:int|npt.ArrayLike, krigtype:int|str|enum.KrigType, vartype:int|str|enum.VarioType|npt.ArrayLike, ahmax:float|npt.ArrayLike, ahmin:float|npt.ArrayLike, avert:float|npt.ArrayLike, bearing:float|npt.ArrayLike, dip:float|npt.ArrayLike, rake:float|npt.ArrayLike, srhmax:float, srhmin:float, srvert:float, maxpts:int, minpts:int, factorfile:str|PathLike, factorfiletype:int|str|enum.FactorFileType) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate 3D kriging factors.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ecs</code></strong>, <strong><code>ncs</code></strong>, <strong><code>zcs</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Source point coordinates, each 1D array with shape (npts,).</dd>
<dt><strong><code>zns</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Source point zones, integer or 1D array with shape (npts,).</dd>
<dt><strong><code>ect</code></strong>, <strong><code>nct</code></strong>, <strong><code>zct</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Target point coordinates, each 1D array with shape (mpts,).</dd>
<dt><strong><code>znt</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Target point zones, integer or 1D array with shape (mpts,).</dd>
<dt><strong><code>krigtype</code></strong> :&ensp;<code>int, str,</code> or <code>enum.KrigType,</code></dt>
<dd>Kriging type, where 0:simple, 1:ordinary.</dd>
<dt><strong><code>zonenum</code></strong> :&ensp;<code>int,</code> or <code>array_like</code></dt>
<dd>Zone numbers, inteter or 1D array with shape (nzone,).</dd>
<dt><strong><code>vartype</code></strong> :&ensp;<code>int, str, enum.VarioType</code> or <code>array_like</code></dt>
<dd>Variogram type, where 1:spher, 2:exp, 3:gauss, 4:pow. If array,
then it should have shape (nzone,).</dd>
<dt><strong><code>ahmax</code></strong>, <strong><code>ahmin</code></strong>, <strong><code>avert</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Variogram "a" values in 3 orthogonal directions (hmax, hmin, vert).
Each can be a float or 1D array with shape (nzone,).</dd>
<dt><strong><code>bearing</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Bearing of hmax, float or 1D array with shape (nzone,).</dd>
<dt><strong><code>dip</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Dip of hmax, float or 1D array with shape (nzone,).</dd>
<dt><strong><code>rake</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Twist about hmax axis, float or 1D array with shape (nzone,).</dd>
<dt><strong><code>srhmax</code></strong>, <strong><code>srhmin</code></strong>, <strong><code>srvert</code></strong> :&ensp;<code>float</code></dt>
<dd>Search radius in hmax, hmin, and vert directions.</dd>
<dt><strong><code>maxpts</code></strong>, <strong><code>minpts</code></strong> :&ensp;<code>int</code></dt>
<dd>Search specifications.</dd>
<dt><strong><code>factorfile</code></strong> :&ensp;<code>str</code> or <code>PathLike</code></dt>
<dd>File for kriging factors.</dd>
<dt><strong><code>factorfiletype</code></strong> :&ensp;<code>int, str</code> or <code>enum.FactorFileType</code></dt>
<dd>Factor file type, where 0:binary, 1:text.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Number of interp points.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_kriging_factors_3d(
    self,
    # npts: int,  # determined from ecs.shape[0]
    ecs: npt.ArrayLike,
    ncs: npt.ArrayLike,
    zcs: npt.ArrayLike,
    zns: int | npt.ArrayLike,
    # mpts: int,  # determined from ect.shape[0]
    ect: npt.ArrayLike,
    nct: npt.ArrayLike,
    zct: npt.ArrayLike,
    znt: int | npt.ArrayLike,
    zonenum: int | npt.ArrayLike,
    krigtype: int | str | enum.KrigType,
    # nzone: int,  # determined from shape[0] from any zonenum..rake else 1
    vartype: int | str | enum.VarioType | npt.ArrayLike,
    ahmax: float | npt.ArrayLike,
    ahmin: float | npt.ArrayLike,
    avert: float | npt.ArrayLike,
    bearing: float | npt.ArrayLike,
    dip: float | npt.ArrayLike,
    rake: float | npt.ArrayLike,
    srhmax: float,
    srhmin: float,
    srvert: float,
    maxpts: int,
    minpts: int,
    factorfile: str | PathLike,
    factorfiletype: int | str | enum.FactorFileType,
) -&gt; int:
    &#34;&#34;&#34;
    Calculate 3D kriging factors.

    Parameters
    ----------
    ecs, ncs, zcs : array_like
        Source point coordinates, each 1D array with shape (npts,).
    zns : int or array_like
        Source point zones, integer or 1D array with shape (npts,).
    ect, nct, zct : array_like
        Target point coordinates, each 1D array with shape (mpts,).
    znt : int or array_like
        Target point zones, integer or 1D array with shape (mpts,).
    krigtype : int, str, or enum.KrigType,
        Kriging type, where 0:simple, 1:ordinary.
    zonenum : int, or array_like
        Zone numbers, inteter or 1D array with shape (nzone,).
    vartype : int, str, enum.VarioType or array_like
        Variogram type, where 1:spher, 2:exp, 3:gauss, 4:pow. If array,
        then it should have shape (nzone,).
    ahmax, ahmin, avert : float or array_like
        Variogram &#34;a&#34; values in 3 orthogonal directions (hmax, hmin, vert).
        Each can be a float or 1D array with shape (nzone,).
    bearing : float or array_like
        Bearing of hmax, float or 1D array with shape (nzone,).
    dip : float or array_like
        Dip of hmax, float or 1D array with shape (nzone,).
    rake : float or array_like
        Twist about hmax axis, float or 1D array with shape (nzone,).
    srhmax, srhmin, srvert : float
        Search radius in hmax, hmin, and vert directions.
    maxpts, minpts : int
        Search specifications.
    factorfile : str or PathLike
        File for kriging factors.
    factorfiletype : int, str or enum.FactorFileType
        Factor file type, where 0:binary, 1:text.

    Returns
    -------
    int
        Number of interp points.
    &#34;&#34;&#34;
    npta = ManyArrays({&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs, &#34;zcs&#34;: zcs}, int_any={&#34;zns&#34;: zns})
    npts = len(npta)
    mpta = ManyArrays({&#34;ect&#34;: ect, &#34;nct&#34;: nct, &#34;zct&#34;: zct}, int_any={&#34;znt&#34;: znt})
    mpts = len(mpta)
    if isinstance(krigtype, str):
        krigtype = enum.KrigType.get_value(krigtype)
    vartype = np.array(vartype)
    if np.issubdtype(vartype.dtype, str):
        vartype = np.vectorize(enum.VarioType.get_value)(vartype)
    if not np.issubdtype(vartype.dtype, np.integer):
        raise ValueError(&#34;expected &#39;vartype&#39; to be integer, str or enum.VarioType&#34;)
    nzone = ManyArrays(
        float_any={
            &#34;ahmax&#34;: ahmax,
            &#34;ahmin&#34;: ahmin,
            &#34;avert&#34;: avert,
            &#34;bearing&#34;: bearing,
            &#34;dip&#34;: dip,
            &#34;rake&#34;: rake,
        },
        int_any={&#34;zonenum&#34;: zonenum, &#34;vartype&#34;: vartype},
    )
    factorfile = Path(factorfile)
    if isinstance(factorfiletype, str):
        factorfiletype = enum.FactorFileType.get_value(factorfiletype)
    icount_interp = c_int()
    res = self.pestutils.calc_kriging_factors_3d(
        byref(c_int(npts)),
        npta.ecs,
        npta.ncs,
        npta.zcs,
        npta.zns,
        byref(c_int(mpts)),
        mpta.ect,
        mpta.nct,
        mpta.zct,
        mpta.znt,
        byref(c_int(krigtype)),
        byref(c_int(len(nzone))),
        nzone.zonenum,
        nzone.vartype,
        nzone.ahmax,
        nzone.ahmin,
        nzone.avert,
        nzone.bearing,
        nzone.dip,
        nzone.rake,
        byref(c_double(srhmax)),
        byref(c_double(srhmin)),
        byref(c_double(srvert)),
        byref(c_int(maxpts)),
        byref(c_int(minpts)),
        byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
        byref(c_int(factorfiletype)),
        byref(icount_interp),
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;calculated 3D kriging factors to %r&#34;, factorfile.name)
    return icount_interp.value</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.calc_kriging_factors_auto_2d"><code class="name flex">
<span>def <span class="ident">calc_kriging_factors_auto_2d</span></span>(<span>self, ecs:npt.ArrayLike, ncs:npt.ArrayLike, zns:int|npt.ArrayLike, ect:npt.ArrayLike, nct:npt.ArrayLike, znt:int|npt.ArrayLike, krigtype:int|str|enum.KrigType, anis:float|npt.ArrayLike, bearing:float|npt.ArrayLike, factorfile:str|PathLike, factorfiletype:int|str|enum.FactorFileType) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate 2D kriging factors, with automatic variogram properties.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ecs</code></strong>, <strong><code>ncs</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Source point coordinates, each 1D array with shape (npts,).</dd>
<dt><strong><code>zns</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Source point zones, integer or 1D array with shape (npts,).</dd>
<dt><strong><code>ect</code></strong>, <strong><code>nct</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Target point coordinates, each 1D array with shape (mpts,).</dd>
<dt><strong><code>znt</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Target point zones, integer or 1D array with shape (mpts,).</dd>
<dt><strong><code>krigtype</code></strong> :&ensp;<code>int, str, enum.KrigType</code></dt>
<dd>Kriging type, where 0:simple, 1:ordinary.</dd>
<dt><strong><code>anis</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Variogram anisotropies, float or 1D array with shape (mpts,).</dd>
<dt><strong><code>bearing</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Variogram bearings, float or 1D array with shape (mpts,).</dd>
<dt><strong><code>factorfile</code></strong> :&ensp;<code>str</code> or <code>PathLike</code></dt>
<dd>File for kriging factors.</dd>
<dt><strong><code>factorfiletype</code></strong> :&ensp;<code>int, str</code> or <code>enum.FactorFileType</code></dt>
<dd>Factor file type, where 0:binary, 1:text.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Number of interp points.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_kriging_factors_auto_2d(
    self,
    # npts: int,  # determined from ecs.shape[0]
    ecs: npt.ArrayLike,
    ncs: npt.ArrayLike,
    zns: int | npt.ArrayLike,
    # mpts: int,  # determined from ect.shape[0]
    ect: npt.ArrayLike,
    nct: npt.ArrayLike,
    znt: int | npt.ArrayLike,
    krigtype: int | str | enum.KrigType,
    anis: float | npt.ArrayLike,
    bearing: float | npt.ArrayLike,
    factorfile: str | PathLike,
    factorfiletype: int | str | enum.FactorFileType,
) -&gt; int:
    &#34;&#34;&#34;
    Calculate 2D kriging factors, with automatic variogram properties.

    Parameters
    ----------
    ecs, ncs : array_like
        Source point coordinates, each 1D array with shape (npts,).
    zns : int or array_like
        Source point zones, integer or 1D array with shape (npts,).
    ect, nct : array_like
        Target point coordinates, each 1D array with shape (mpts,).
    znt : int or array_like
        Target point zones, integer or 1D array with shape (mpts,).
    krigtype : int, str, enum.KrigType
        Kriging type, where 0:simple, 1:ordinary.
    anis : float or array_like
        Variogram anisotropies, float or 1D array with shape (mpts,).
    bearing : float or array_like
        Variogram bearings, float or 1D array with shape (mpts,).
    factorfile : str or PathLike
        File for kriging factors.
    factorfiletype : int, str or enum.FactorFileType
        Factor file type, where 0:binary, 1:text.

    Returns
    -------
    int
        Number of interp points.
    &#34;&#34;&#34;
    npta = ManyArrays({&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs}, int_any={&#34;zns&#34;: zns})
    npts = len(npta)
    mpta = ManyArrays(
        {&#34;ect&#34;: ect, &#34;nct&#34;: nct}, {&#34;anis&#34;: anis, &#34;bearing&#34;: bearing}, {&#34;znt&#34;: znt}
    )
    mpts = len(mpta)
    if isinstance(krigtype, str):
        krigtype = enum.KrigType.get_value(krigtype)
    factorfile = Path(factorfile)
    if isinstance(factorfiletype, str):
        factorfiletype = enum.FactorFileType.get_value(factorfiletype)
    icount_interp = c_int()
    res = self.pestutils.calc_kriging_factors_auto_2d(
        byref(c_int(npts)),
        npta.ecs,
        npta.ncs,
        npta.zns,
        byref(c_int(mpts)),
        mpta.ect,
        mpta.nct,
        mpta.znt,
        byref(c_int(krigtype)),
        mpta.anis,
        mpta.bearing,
        byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
        byref(c_int(factorfiletype)),
        byref(icount_interp),
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;calculated 2D auto kriging factors to %r&#34;, factorfile.name)
    return icount_interp.value</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.calc_mf6_interp_factors"><code class="name flex">
<span>def <span class="ident">calc_mf6_interp_factors</span></span>(<span>self, gridname:str, ecoord:npt.ArrayLike, ncoord:npt.ArrayLike, layer:int|npt.ArrayLike, factorfile:str|PathLike, factorfiletype:int|str|enum.FactorFileType, blnfile:str|PathLike) >numpy.ndarray[typing.Any,numpy.dtype[numpy.int32]]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate interpolation factors from a MODFLOW 6 DIS or DISV.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gridname</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique non-blank grid name.</dd>
<dt><strong><code>ecoord</code></strong>, <strong><code>ncoord</code></strong> :&ensp;<code>array_like</code></dt>
<dd>X/Y or Easting/Northing coordinates for points with shape (npts,).</dd>
<dt><strong><code>layer</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Layers of points with shape (npts,).</dd>
<dt><strong><code>factorfile</code></strong> :&ensp;<code>str</code> or <code>PathLike</code></dt>
<dd>File for kriging factors to write.</dd>
<dt><strong><code>factorfiletype</code></strong> :&ensp;<code>int, str</code> or <code>enum.FactorFileType</code></dt>
<dd>Factor file type, where 0:binary, 1:text.</dd>
<dt><strong><code>blnfile</code></strong> :&ensp;<code>str</code> or <code>PathLike</code></dt>
<dd>Name of bln file to write.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>npt.NDArray[np.int32]</code></dt>
<dd>Array interp_success(npts), where 1 is success and 0 is failure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_mf6_interp_factors(
    self,
    gridname: str,
    # npts: int,  # determined from ecoord.shape[0]
    ecoord: npt.ArrayLike,
    ncoord: npt.ArrayLike,
    layer: int | npt.ArrayLike,
    factorfile: str | PathLike,
    factorfiletype: int | str | enum.FactorFileType,
    blnfile: str | PathLike,
) -&gt; npt.NDArray[np.int32]:
    &#34;&#34;&#34;Calculate interpolation factors from a MODFLOW 6 DIS or DISV.

    Parameters
    ----------
    gridname : str
        Unique non-blank grid name.
    ecoord, ncoord : array_like
        X/Y or Easting/Northing coordinates for points with shape (npts,).
    layer : int or array_like
        Layers of points with shape (npts,).
    factorfile : str or PathLike
        File for kriging factors to write.
    factorfiletype : int, str or enum.FactorFileType
        Factor file type, where 0:binary, 1:text.
    blnfile : str or PathLike
        Name of bln file to write.

    Returns
    -------
    npt.NDArray[np.int32]
        Array interp_success(npts), where 1 is success and 0 is failure.
    &#34;&#34;&#34;
    pta = ManyArrays({&#34;ecoord&#34;: ecoord, &#34;ncoord&#34;: ncoord}, int_any={&#34;layer&#34;: layer})
    npts = len(pta)
    factorfile = Path(factorfile)
    if isinstance(factorfiletype, str):
        factorfiletype = enum.FactorFileType.get_value(factorfiletype)
    blnfile = Path(blnfile)
    interp_success = np.zeros(npts, np.int32, order=&#34;F&#34;)
    res = self.pestutils.calc_mf6_interp_factors(
        byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
        byref(c_int(npts)),
        pta.ecoord,
        pta.ncoord,
        pta.layer,
        byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
        byref(c_int(factorfiletype)),
        byref(self.create_char_array(bytes(blnfile), &#34;LENFILENAME&#34;)),
        interp_success,
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;calculated mf6 interp factors for %r&#34;, gridname)
    return interp_success.copy(&#34;A&#34;)</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.calc_structural_overlay_factors"><code class="name flex">
<span>def <span class="ident">calc_structural_overlay_factors</span></span>(<span>self, ecs:npt.ArrayLike, ncs:npt.ArrayLike, ids:int|npt.ArrayLike, conwidth:npt.ArrayLike, aa:npt.ArrayLike, structype:int|str|enum.StrucType, inverse_power:float, ect:npt.ArrayLike, nct:npt.ArrayLike, active:int|npt.ArrayLike, factorfile:str|PathLike, factorfiletype:int|str|enum.FactorFileType) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate interpolation/blending factors for structural overlay parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ecs</code></strong>, <strong><code>ncs</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Source point coordinates, each 1D array with shape (npts,).</dd>
<dt><strong><code>ids</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Source point structure number, integer or 1D array with shape (npts,).</dd>
<dt><strong><code>conwidth</code></strong>, <strong><code>aa</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Blending parameters, float or 1D array with shape (npts,).</dd>
<dt><strong><code>structype</code></strong> :&ensp;<code>int, str</code> or <code>enum.StrucType</code></dt>
<dd>Structure type, where 0 is polylinear and 1 is polygonal.</dd>
<dt><strong><code>inverse_power</code></strong> :&ensp;<code>float</code></dt>
<dd>Inverse power of distance.</dd>
<dt><strong><code>ect</code></strong>, <strong><code>nct</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Target point coordinates, each 1D array with shape (mpts,).</dd>
<dt><strong><code>active</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Target point activity, integer or 1D array with shape (mpts,).</dd>
<dt><strong><code>factorfile</code></strong> :&ensp;<code>str</code> or <code>PathLike</code></dt>
<dd>File for kriging factors.</dd>
<dt><strong><code>factorfiletype</code></strong> :&ensp;<code>int, str</code> or <code>enum.FactorFileType</code></dt>
<dd>Factor file type, where 0:binary, 1:text.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Number of interp points.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_structural_overlay_factors(
    self,
    # npts: int,  # determined from ecs.shape[0]
    ecs: npt.ArrayLike,
    ncs: npt.ArrayLike,
    ids: int | npt.ArrayLike,
    conwidth: npt.ArrayLike,
    aa: npt.ArrayLike,
    structype: int | str | enum.StrucType,
    inverse_power: float,
    # mpts: int,  # determined from ect.shape[0]
    ect: npt.ArrayLike,
    nct: npt.ArrayLike,
    active: int | npt.ArrayLike,
    factorfile: str | PathLike,
    factorfiletype: int | str | enum.FactorFileType,
) -&gt; int:
    &#34;&#34;&#34;
    Calculate interpolation/blending factors for structural overlay parameters.

    Parameters
    ----------
    ecs, ncs : array_like
        Source point coordinates, each 1D array with shape (npts,).
    ids : int or array_like
        Source point structure number, integer or 1D array with shape (npts,).
    conwidth, aa : float or array_like
        Blending parameters, float or 1D array with shape (npts,).
    structype : int, str or enum.StrucType
        Structure type, where 0 is polylinear and 1 is polygonal.
    inverse_power : float
        Inverse power of distance.
    ect, nct : array_like
        Target point coordinates, each 1D array with shape (mpts,).
    active : int or array_like
        Target point activity, integer or 1D array with shape (mpts,).
    factorfile : str or PathLike
        File for kriging factors.
    factorfiletype : int, str or enum.FactorFileType
        Factor file type, where 0:binary, 1:text.

    Returns
    -------
    int
        Number of interp points.
    &#34;&#34;&#34;
    npta = ManyArrays(
        {&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs}, {&#34;conwidth&#34;: conwidth, &#34;aa&#34;: aa}, {&#34;ids&#34;: ids}
    )
    npts = len(npta)
    mpta = ManyArrays({&#34;ect&#34;: ect, &#34;nct&#34;: nct}, int_any={&#34;active&#34;: active})
    mpts = len(mpta)
    if isinstance(structype, str):
        structype = enum.StrucType.get_value(structype)
    factorfile = Path(factorfile)
    if isinstance(factorfiletype, str):
        factorfiletype = enum.FactorFileType.get_value(factorfiletype)
    icount_interp = c_int()
    res = self.pestutils.calc_structural_overlay_factors(
        byref(c_int(npts)),
        npta.ecs,
        npta.ncs,
        npta.ids,
        npta.conwidth,
        npta.aa,
        byref(c_int(structype)),
        byref(c_double(inverse_power)),
        byref(c_int(mpts)),
        mpta.ect,
        mpta.nct,
        mpta.active,
        byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
        byref(c_int(factorfiletype)),
        byref(icount_interp),
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(
        &#34;calculated interpolation/blending factors to %r&#34;, factorfile.name
    )
    return icount_interp.value</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.create_char_array"><code class="name flex">
<span>def <span class="ident">create_char_array</span></span>(<span>self, init:str|bytes, name:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Create c_char Array with a fixed size from dimvar and intial value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>init</code></strong> :&ensp;<code>str</code> or <code>bytes</code></dt>
<dd>Initial value.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Uppercase variable length name, e.g. LENFILENAME or LENVARTYPE.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_char_array(self, init: str | bytes, name: str):
    &#34;&#34;&#34;Create c_char Array with a fixed size from dimvar and intial value.

    Parameters
    ----------
    init : str or bytes
        Initial value.
    name : str
        Uppercase variable length name, e.g. LENFILENAME or LENVARTYPE.
    &#34;&#34;&#34;
    from .ctypes_declarations import get_dimvar_int

    if isinstance(init, str):
        init = init.encode()
    elif isinstance(init, bytes):
        pass
    else:
        raise TypeError(f&#34;expecting either str or bytes; found {type(init)}&#34;)
    size = get_dimvar_int(self.pestutils, name)
    if len(init) &gt; size:
        raise ValueError(f&#34;init size is {len(init)} but {name} is {size}&#34;)
    return create_string_buffer(init, size)</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.extract_flows_from_cbc_file"><code class="name flex">
<span>def <span class="ident">extract_flows_from_cbc_file</span></span>(<span>self, cbcfile:str|PathLike, flowtype:str, isim:int, iprec:int|str|enum.Prec, izone:npt.ArrayLike, nzone:int, ntime:int) >dict</span>
</code></dt>
<dd>
<div class="desc"><p>Read and accumulates flows from a CBC flow file to a user-specified BC.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cbcfile</code></strong> :&ensp;<code>str | PathLike</code></dt>
<dd>Cell-by-cell flow term file written by any MF version.</dd>
<dt><strong><code>flowtype</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of flow to read.</dd>
<dt><strong><code>isim</code></strong> :&ensp;<code>int</code></dt>
<dd>Simulator type.</dd>
<dt><strong><code>iprec</code></strong> :&ensp;<code>int, str</code> or <code>enum.Prec</code></dt>
<dd>Precision used to record real variables in cbc file.</dd>
<dt><strong><code>izone</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Zonation of model domain, with shape (ncell,).</dd>
<dt><strong><code>nzone</code></strong> :&ensp;<code>int</code></dt>
<dd>Equals or exceeds number of zones; zone 0 doesn't count.</dd>
<dt><strong><code>ntime</code></strong> :&ensp;<code>int</code></dt>
<dd>Equals or exceed number of model output times for flow type.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>numzone</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of non-zero-valued zones.</dd>
<dt><strong><code>zonenumber</code></strong> :&ensp;<code>npt.NDArray[np.int32]</code></dt>
<dd>Zone numbers, with shape (nzone,).</dd>
<dt><strong><code>nproctime</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of processed simulation times.</dd>
<dt><strong><code>timestep</code></strong> :&ensp;<code>npt.NDArray[np.int32]</code></dt>
<dd>Simulation time step, with shape (ntime,).</dd>
<dt><strong><code>stressperiod</code></strong> :&ensp;<code>npt.NDArray[np.int32]</code></dt>
<dd>Simulation stress period, with shape (ntime,).</dd>
<dt><strong><code>simtime</code></strong> :&ensp;<code>npt.NDArray[np.int32]</code></dt>
<dd>Simulation time, with shape (ntime,).
A time of -1.0 indicates unknown.</dd>
<dt><strong><code>simflow</code></strong> :&ensp;<code>npt.NDArray[np.int32]</code></dt>
<dd>Interpolated flows, with shape (ntime, nzone).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_flows_from_cbc_file(
    self,
    cbcfile: str | PathLike,
    flowtype: str,
    isim: int,
    iprec: int | str | enum.Prec,
    # ncell: int,  # from izone.shape[0]
    izone: npt.ArrayLike,
    nzone: int,
    ntime: int,
) -&gt; dict:
    &#34;&#34;&#34;
    Read and accumulates flows from a CBC flow file to a user-specified BC.

    Parameters
    ----------
    cbcfile : str | PathLike
        Cell-by-cell flow term file written by any MF version.
    flowtype : str
        Type of flow to read.
    isim : int
        Simulator type.
    iprec : int, str or enum.Prec
        Precision used to record real variables in cbc file.
    izone : array_like
        Zonation of model domain, with shape (ncell,).
    nzone : int
        Equals or exceeds number of zones; zone 0 doesn&#39;t count.
    ntime : int
        Equals or exceed number of model output times for flow type.

    Returns
    -------
    numzone : int
        Number of non-zero-valued zones.
    zonenumber : npt.NDArray[np.int32]
        Zone numbers, with shape (nzone,).
    nproctime : int
        Number of processed simulation times.
    timestep : npt.NDArray[np.int32]
        Simulation time step, with shape (ntime,).
    stressperiod : npt.NDArray[np.int32]
        Simulation stress period, with shape (ntime,).
    simtime : npt.NDArray[np.int32]
        Simulation time, with shape (ntime,).
        A time of -1.0 indicates unknown.
    simflow : npt.NDArray[np.int32]
        Interpolated flows, with shape (ntime, nzone).
    &#34;&#34;&#34;
    cbcfile = Path(cbcfile)
    if not cbcfile.is_file():
        raise FileNotFoundError(f&#34;could not find cbcfile {cbcfile}&#34;)
    validate_scalar(&#34;flowtype&#34;, flowtype, minlen=1)
    validate_scalar(&#34;iprec&#34;, iprec, enum=enum.Prec)
    if isinstance(iprec, str):
        iprec = enum.Prec.get_value(iprec)
    cell = ManyArrays(int_any={&#34;izone&#34;: izone})
    ncell = len(cell)
    numzone = c_int()
    zonenumber = np.zeros(nzone, np.int32, order=&#34;F&#34;)
    nproctime = c_int()
    timestep = np.zeros(ntime, np.int32, order=&#34;F&#34;)
    stressperiod = np.zeros(ntime, np.int32, order=&#34;F&#34;)
    simtime = np.zeros(ntime, np.float64, order=&#34;F&#34;)
    simflow = np.zeros((ntime, nzone), np.float64, order=&#34;F&#34;)
    res = self.pestutils.extract_flows_from_cbc_file(
        byref(self.create_char_array(bytes(cbcfile), &#34;LENFILENAME&#34;)),
        byref(self.create_char_array(flowtype, &#34;LENFLOWTYPE&#34;)),
        byref(c_int(isim)),
        byref(c_int(iprec)),
        byref(c_int(ncell)),
        cell.izone,
        byref(c_int(nzone)),
        byref(numzone),
        zonenumber,
        byref(c_int(ntime)),
        byref(nproctime),
        timestep,
        stressperiod,
        simtime,
        simflow,
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;extracted flows from %r&#34;, cbcfile.name)
    return {
        &#34;numzone&#34;: numzone.value,
        &#34;zonenumber&#34;: zonenumber.copy(&#34;A&#34;),
        &#34;nproctime&#34;: nproctime.value,
        &#34;timestep&#34;: timestep.copy(&#34;A&#34;),
        &#34;stressperiod&#34;: stressperiod.copy(&#34;A&#34;),
        &#34;simtime&#34;: simtime.copy(&#34;A&#34;),
        &#34;simflow&#34;: simflow.copy(&#34;A&#34;),
    }</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.fieldgen2d_sva"><code class="name flex">
<span>def <span class="ident">fieldgen2d_sva</span></span>(<span>self, ec:npt.ArrayLike, nc:npt.ArrayLike, area:float|npt.ArrayLike, active:int|npt.ArrayLike, mean:float|npt.ArrayLike, var:float|npt.ArrayLike, aa:float|npt.ArrayLike, anis:float|npt.ArrayLike, bearing:float|npt.ArrayLike, transtype:int|str|enum.TransType, avetype:int|str|enum.VarioType, power:float, nreal:int) >numpy.ndarray[typing.Any,numpy.dtype[numpy.float64]]</span>
</code></dt>
<dd>
<div class="desc"><p>Generate 2D stochastic fields based on a spatially varying variogram.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ec</code></strong>, <strong><code>nc</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Model grid coordinates, each 1D array with shape (nnode,).</dd>
<dt><strong><code>area</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Areas of grid cells.</dd>
<dt><strong><code>active</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Inactive grid cells are equal to zero.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Mean value of stochastic field.</dd>
<dt><strong><code>var</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Variance of stochastic field.</dd>
<dt><strong><code>aa</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Averaging function spatial dimension.</dd>
<dt><strong><code>anis</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Anisotropy ratio.</dd>
<dt><strong><code>bearing</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Bearing of principal anisotropy axis.</dd>
<dt><strong><code>transtype</code></strong> :&ensp;<code>int, str</code> or <code>enum.TransType</code></dt>
<dd>Stochastic field pertains to natural(0) or log(1) properties.</dd>
<dt><strong><code>avetype</code></strong> :&ensp;<code>int, str</code> or <code>enum.VarioType</code></dt>
<dd>Averaging function type, where 1:spher, 2:exp, 3:gauss, 4:pow.</dd>
<dt><strong><code>power</code></strong> :&ensp;<code>float</code></dt>
<dd>Power used if avetype is 4 (pow).</dd>
<dt><strong><code>nreal</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of realisations to generate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>npt.NDArray[np.float64]</code></dt>
<dd>Realisations with shape (nnode, nreal).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fieldgen2d_sva(
    self,
    # nnode: int,  # determined from ec.shape[0]
    ec: npt.ArrayLike,
    nc: npt.ArrayLike,
    area: float | npt.ArrayLike,
    active: int | npt.ArrayLike,
    mean: float | npt.ArrayLike,
    var: float | npt.ArrayLike,
    aa: float | npt.ArrayLike,
    anis: float | npt.ArrayLike,
    bearing: float | npt.ArrayLike,
    transtype: int | str | enum.TransType,
    avetype: int | str | enum.VarioType,
    power: float,
    # ldrand: int,  # same as nnode
    nreal: int,
) -&gt; npt.NDArray[np.float64]:
    &#34;&#34;&#34;
    Generate 2D stochastic fields based on a spatially varying variogram.

    Parameters
    ----------
    ec, nc : array_like
        Model grid coordinates, each 1D array with shape (nnode,).
    area : float or array_like
        Areas of grid cells.
    active : int or array_like
        Inactive grid cells are equal to zero.
    mean : float or array_like
        Mean value of stochastic field.
    var : float or array_like
        Variance of stochastic field.
    aa : float or array_like
        Averaging function spatial dimension.
    anis : float or array_like
        Anisotropy ratio.
    bearing : float or array_like
        Bearing of principal anisotropy axis.
    transtype : int, str or enum.TransType
        Stochastic field pertains to natural(0) or log(1) properties.
    avetype : int, str or enum.VarioType
        Averaging function type, where 1:spher, 2:exp, 3:gauss, 4:pow.
    power : float
        Power used if avetype is 4 (pow).
    nreal : int
        Number of realisations to generate.

    Returns
    -------
    npt.NDArray[np.float64]
        Realisations with shape (nnode, nreal).
    &#34;&#34;&#34;
    node = ManyArrays(
        {&#34;ec&#34;: ec, &#34;nc&#34;: nc},
        {
            &#34;area&#34;: area,
            &#34;mean&#34;: mean,
            &#34;var&#34;: var,
            &#34;aa&#34;: aa,
            &#34;anis&#34;: anis,
            &#34;bearing&#34;: bearing,
        },
        {&#34;active&#34;: active},
    )
    if isinstance(transtype, str):
        transtype = enum.TransType.get_value(transtype)
    if isinstance(avetype, str):
        avetype = enum.VarioType.get_value(avetype)
    ldrand = nnode = len(node)
    randfield = np.zeros((ldrand, nreal), np.float64, order=&#34;F&#34;)
    res = self.pestutils.fieldgen2d_sva(
        byref(c_int(nnode)),
        node.ec,
        node.nc,
        node.area,
        node.active,
        node.mean,
        node.var,
        node.aa,
        node.anis,
        node.bearing,
        byref(c_int(transtype)),
        byref(c_int(avetype)),
        byref(c_double(power)),
        byref(c_int(ldrand)),
        byref(c_int(nreal)),
        randfield,
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;generated 2D stochastic fields for %d realisations&#34;, nreal)
    return randfield.copy(&#34;A&#34;)</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.fieldgen3d_sva"><code class="name flex">
<span>def <span class="ident">fieldgen3d_sva</span></span>(<span>self, ec:npt.ArrayLike, nc:npt.ArrayLike, zc:npt.ArrayLike, area:float|npt.ArrayLike, height:float|npt.ArrayLike, active:int|npt.ArrayLike, mean:float|npt.ArrayLike, var:float|npt.ArrayLike, ahmax:float|npt.ArrayLike, ahmin:float|npt.ArrayLike, avert:float|npt.ArrayLike, bearing:float|npt.ArrayLike, dip:float|npt.ArrayLike, rake:float|npt.ArrayLike, transtype:int|str|enum.TransType, avetype:int|str|enum.VarioType, power:float, nreal:int) >numpy.ndarray[typing.Any,numpy.dtype[numpy.float64]]</span>
</code></dt>
<dd>
<div class="desc"><p>Generate 3D stochastic fields based on a spatially varying variogram.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ec</code></strong>, <strong><code>nc</code></strong>, <strong><code>nz</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Model grid coordinates, each 1D array with shape (nnode,).</dd>
<dt><strong><code>area</code></strong>, <strong><code>height</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Areas and height of grid cells.</dd>
<dt><strong><code>active</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Inactive grid cells are equal to zero.</dd>
<dt><strong><code>mean</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Mean value of stochastic field.</dd>
<dt><strong><code>var</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Variance of stochastic field.</dd>
<dt><strong><code>ahmax</code></strong>, <strong><code>ahmin</code></strong>, <strong><code>avert</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Averaging function correlation lengths.</dd>
<dt><strong><code>bearing</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Bearing of ahmax direction.</dd>
<dt><strong><code>dip</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Dip of ahmax direction.</dd>
<dt><strong><code>rake</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Rotation of ahmin direction.</dd>
<dt><strong><code>transtype</code></strong> :&ensp;<code>int, str</code> or <code>enum.TransType</code></dt>
<dd>Stochastic field pertains to natural(0) or log(1) properties.</dd>
<dt><strong><code>avetype</code></strong> :&ensp;<code>int, str</code> or <code>enum.VarioType</code></dt>
<dd>Averaging function type, where 1:spher, 2:exp, 3:gauss, 4:pow.</dd>
<dt><strong><code>power</code></strong> :&ensp;<code>float</code></dt>
<dd>Power used if avetype is 4 (pow).</dd>
<dt><strong><code>nreal</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of realisations to generate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>npt.NDArray[np.float64]</code></dt>
<dd>Realisations with shape (nnode, nreal).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fieldgen3d_sva(
    self,
    # nnode: int,  # determined from ec.shape[0]
    ec: npt.ArrayLike,
    nc: npt.ArrayLike,
    zc: npt.ArrayLike,
    area: float | npt.ArrayLike,
    height: float | npt.ArrayLike,
    active: int | npt.ArrayLike,
    mean: float | npt.ArrayLike,
    var: float | npt.ArrayLike,
    ahmax: float | npt.ArrayLike,
    ahmin: float | npt.ArrayLike,
    avert: float | npt.ArrayLike,
    bearing: float | npt.ArrayLike,
    dip: float | npt.ArrayLike,
    rake: float | npt.ArrayLike,
    transtype: int | str | enum.TransType,
    avetype: int | str | enum.VarioType,
    power: float,
    # ldrand: int,  # same as nnode
    nreal: int,
) -&gt; npt.NDArray[np.float64]:
    &#34;&#34;&#34;
    Generate 3D stochastic fields based on a spatially varying variogram.

    Parameters
    ----------
    ec, nc, nz : array_like
        Model grid coordinates, each 1D array with shape (nnode,).
    area, height : float or array_like
        Areas and height of grid cells.
    active : int or array_like
        Inactive grid cells are equal to zero.
    mean : float or array_like
        Mean value of stochastic field.
    var : float or array_like
        Variance of stochastic field.
    ahmax, ahmin, avert : float or array_like
        Averaging function correlation lengths.
    bearing : float or array_like
        Bearing of ahmax direction.
    dip : float or array_like
        Dip of ahmax direction.
    rake : float or array_like
        Rotation of ahmin direction.
    transtype : int, str or enum.TransType
        Stochastic field pertains to natural(0) or log(1) properties.
    avetype : int, str or enum.VarioType
        Averaging function type, where 1:spher, 2:exp, 3:gauss, 4:pow.
    power : float
        Power used if avetype is 4 (pow).
    nreal : int
        Number of realisations to generate.

    Returns
    -------
    npt.NDArray[np.float64]
        Realisations with shape (nnode, nreal).
    &#34;&#34;&#34;
    node = ManyArrays(
        {&#34;ec&#34;: ec, &#34;nc&#34;: nc, &#34;zc&#34;: zc},
        {
            &#34;area&#34;: area,
            &#34;height&#34;: height,
            &#34;mean&#34;: mean,
            &#34;var&#34;: var,
            &#34;ahmax&#34;: ahmax,
            &#34;ahmin&#34;: ahmin,
            &#34;avert&#34;: avert,
            &#34;bearing&#34;: bearing,
            &#34;dip&#34;: dip,
            &#34;rake&#34;: rake,
        },
        {&#34;active&#34;: active},
    )
    if isinstance(transtype, str):
        transtype = enum.TransType.get_value(transtype)
    if isinstance(avetype, str):
        avetype = enum.VarioType.get_value(avetype)
    ldrand = nnode = len(node)
    randfield = np.zeros((ldrand, nreal), np.float64, order=&#34;F&#34;)
    res = self.pestutils.fieldgen3d_sva(
        byref(c_int(nnode)),
        node.ec,
        node.nc,
        node.zc,
        node.area,
        node.height,
        node.active,
        node.mean,
        node.var,
        node.ahmax,
        node.ahmin,
        node.avert,
        node.bearing,
        node.dip,
        node.rake,
        byref(c_int(transtype)),
        byref(c_int(avetype)),
        byref(c_double(power)),
        byref(c_int(ldrand)),
        byref(c_int(nreal)),
        randfield,
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;generated 3D stochastic fields for %d realisations&#34;, nreal)
    return randfield.copy(&#34;A&#34;)</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.free_all_memory"><code class="name flex">
<span>def <span class="ident">free_all_memory</span></span>(<span>self) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Deallocate all memory that is being used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def free_all_memory(self) -&gt; None:
    &#34;&#34;&#34;Deallocate all memory that is being used.&#34;&#34;&#34;
    ret = self.pestutils.free_all_memory()
    if ret != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;all memory was freed up&#34;)</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.get_cell_centres_mf6"><code class="name flex">
<span>def <span class="ident">get_cell_centres_mf6</span></span>(<span>self, gridname:str, ncells:int) >tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Get cell centres from an installed MF6 grid.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gridname</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of installed MF6 grid.</dd>
<dt><strong><code>ncells</code></strong> :&ensp;<code>int</code></dt>
<dd>Dimensions of grid.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cellx</code></strong>, <strong><code>cellx</code></strong>, <strong><code>cellz</code></strong> :&ensp;<code>npt.NDArray[np.float64]</code></dt>
<dd>Coordinates of cell centres with dimensions (ncells,).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cell_centres_mf6(self, gridname: str, ncells: int) -&gt; tuple:
    &#34;&#34;&#34;Get cell centres from an installed MF6 grid.

    Parameters
    ----------
    gridname : str
        Name of installed MF6 grid.
    ncells : int
        Dimensions of grid.

    Returns
    -------
    cellx, cellx, cellz : npt.NDArray[np.float64]
        Coordinates of cell centres with dimensions (ncells,).
    &#34;&#34;&#34;
    cellx = np.zeros(ncells, np.float64, order=&#34;F&#34;)
    celly = np.zeros(ncells, np.float64, order=&#34;F&#34;)
    cellz = np.zeros(ncells, np.float64, order=&#34;F&#34;)
    res = self.pestutils.get_cell_centres_mf6(
        byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
        byref(c_int(ncells)),
        cellx,
        celly,
        cellz,
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;evaluated %d cell centres from MF6 grid %r&#34;, ncells, gridname)
    return cellx.copy(&#34;A&#34;), celly.copy(&#34;A&#34;), cellz.copy(&#34;A&#34;)</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.get_cell_centres_structured"><code class="name flex">
<span>def <span class="ident">get_cell_centres_structured</span></span>(<span>self, gridname:str, ncpl:int) >tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Get cell centres of a single layer of an installed structured grid.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gridname</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of installed structured grid.</dd>
<dt><strong><code>ncpl</code></strong> :&ensp;<code>int</code></dt>
<dd>Dimensions of grid (nrow x ncol).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cellx</code></strong>, <strong><code>cellx</code></strong> :&ensp;<code>npt.NDArray[np.float64]</code></dt>
<dd>Coordinates of cell centres with dimensions (ncpl,).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cell_centres_structured(self, gridname: str, ncpl: int) -&gt; tuple:
    &#34;&#34;&#34;Get cell centres of a single layer of an installed structured grid.

    Parameters
    ----------
    gridname : str
        Name of installed structured grid.
    ncpl : int
        Dimensions of grid (nrow x ncol).

    Returns
    -------
    cellx, cellx : npt.NDArray[np.float64]
        Coordinates of cell centres with dimensions (ncpl,).
    &#34;&#34;&#34;
    cellx = np.zeros(ncpl, np.float64, order=&#34;F&#34;)
    celly = np.zeros(ncpl, np.float64, order=&#34;F&#34;)
    res = self.pestutils.get_cell_centres_structured(
        byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
        byref(c_int(ncpl)),
        cellx,
        celly,
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(
        &#34;evaluated %d cell centres from structured grid %r&#34;, ncpl, gridname
    )
    return cellx.copy(&#34;A&#34;), celly.copy(&#34;A&#34;)</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.initialize_randgen"><code class="name flex">
<span>def <span class="ident">initialize_randgen</span></span>(<span>self, iseed:int) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the random number generator.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>iseed</code></strong> :&ensp;<code>int</code></dt>
<dd>Seed value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_randgen(self, iseed: int) -&gt; None:
    &#34;&#34;&#34;
    Initialize the random number generator.

    Parameters
    ----------
    iseed : int
        Seed value.
    &#34;&#34;&#34;
    res = self.pestutils.initialize_randgen(byref(c_int(iseed)))
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;initialized the random number generator&#34;)</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.inquire_modflow_binary_file_specs"><code class="name flex">
<span>def <span class="ident">inquire_modflow_binary_file_specs</span></span>(<span>self, filein:str|PathLike, fileout:str|PathLike|None, isim:int, itype:int) >dict</span>
</code></dt>
<dd>
<div class="desc"><p>Report some of the details of a MODFLOW-written binary file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filein</code></strong> :&ensp;<code>str</code> or <code>PathLike</code></dt>
<dd>MODFLOW-generated binary file to be read.</dd>
<dt><strong><code>fileout</code></strong> :&ensp;<code>str, PathLike, None</code></dt>
<dd>Output file with with table of array headers. Use None or "" for
no output file.</dd>
<dt><strong><code>isim</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>Inform the function the simulator that generated the binary file:</p>
<ul>
<li>1 = traditional MODFLOW</li>
<li>21 = MODFLOW-USG with structured grid</li>
<li>22 = MODFLOW-USG with unstructured grid</li>
<li>31 = MODFLOW 6 with DIS grid</li>
<li>32 = MODFLOW 6 with DISV grid</li>
<li>33 = MODFLOW 6 with DISU grid</li>
</ul>
</dd>
<dt><strong><code>itype</code></strong> :&ensp;<code>int</code></dt>
<dd>Where 1 = system state or dependent variable;
2 = cell-by-cell flows.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>iprec</code></strong> :&ensp;<code>int</code></dt>
<dd>Where 1 = single; 2 = double.</dd>
<dt><strong><code>narray</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of arrays.</dd>
<dt><strong><code>ntime</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of times.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inquire_modflow_binary_file_specs(
    self,
    filein: str | PathLike,
    fileout: str | PathLike | None,
    isim: int,
    itype: int,
) -&gt; dict:
    &#34;&#34;&#34;Report some of the details of a MODFLOW-written binary file.

    Parameters
    ----------
    filein : str or PathLike
        MODFLOW-generated binary file to be read.
    fileout : str, PathLike, None
        Output file with with table of array headers. Use None or &#34;&#34; for
        no output file.
    isim : int
        Inform the function the simulator that generated the binary file:

         * 1 = traditional MODFLOW
         * 21 = MODFLOW-USG with structured grid
         * 22 = MODFLOW-USG with unstructured grid
         * 31 = MODFLOW 6 with DIS grid
         * 32 = MODFLOW 6 with DISV grid
         * 33 = MODFLOW 6 with DISU grid

    itype : int
        Where 1 = system state or dependent variable;
        2 = cell-by-cell flows.

    Returns
    -------
    iprec : int
        Where 1 = single; 2 = double.
    narray : int
        Number of arrays.
    ntime : int
        Number of times.
    &#34;&#34;&#34;
    filein = Path(filein)
    if not filein.is_file():
        raise FileNotFoundError(f&#34;could not find filein {filein}&#34;)
    if fileout:
        fileout = Path(fileout)
    else:
        fileout = b&#34;&#34;
    validate_scalar(&#34;isim&#34;, isim, isin=[1, 21, 22, 31, 32, 33])
    validate_scalar(&#34;itype&#34;, itype, isin=[1, 2])
    iprec = c_int()
    narray = c_int()
    ntime = c_int()
    res = self.pestutils.inquire_modflow_binary_file_specs(
        byref(self.create_char_array(bytes(filein), &#34;LENFILENAME&#34;)),
        byref(self.create_char_array(bytes(fileout), &#34;LENFILENAME&#34;)),
        byref(c_int(isim)),
        byref(c_int(itype)),
        byref(iprec),
        byref(narray),
        byref(ntime),
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;inquired modflow binary file specs from %r&#34;, filein.name)
    return {
        &#34;iprec&#34;: iprec.value,
        &#34;narray&#34;: narray.value,
        &#34;ntime&#34;: ntime.value,
    }</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.install_mf6_grid_from_file"><code class="name flex">
<span>def <span class="ident">install_mf6_grid_from_file</span></span>(<span>self, gridname:str, grbfile:str|PathLike) >dict</span>
</code></dt>
<dd>
<div class="desc"><p>Install specifications for a MF6 grid from a GRB file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gridname</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique non-blank grid name.</dd>
<dt><strong><code>grbfile</code></strong> :&ensp;<code>str</code> or <code>PathLike</code></dt>
<dd>Path to a GRB binary grid file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>idis</code></strong> :&ensp;<code>int</code></dt>
<dd>Where 1 is for DIS and 2 is for DISV.</dd>
<dt><strong><code>ncells</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of cells in the grid.</dd>
<dt><strong><code>ndim1</code></strong>, <strong><code>ndim2</code></strong>, <strong><code>ndim3</code></strong> :&ensp;<code>int</code></dt>
<dd>Grid dimensions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def install_mf6_grid_from_file(
    self, gridname: str, grbfile: str | PathLike
) -&gt; dict:
    &#34;&#34;&#34;Install specifications for a MF6 grid from a GRB file.

    Parameters
    ----------
    gridname : str
        Unique non-blank grid name.
    grbfile : str or PathLike
        Path to a GRB binary grid file.

    Returns
    -------
    idis : int
        Where 1 is for DIS and 2 is for DISV.
    ncells : int
        Number of cells in the grid.
    ndim1, ndim2, ndim3 : int
        Grid dimensions.
    &#34;&#34;&#34;
    grbfile = Path(grbfile)
    if not grbfile.is_file():
        raise FileNotFoundError(f&#34;could not find grbfile {grbfile}&#34;)
    idis = c_int()
    ncells = c_int()
    ndim1 = c_int()
    ndim2 = c_int()
    ndim3 = c_int()
    res = self.pestutils.install_mf6_grid_from_file(
        byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
        byref(self.create_char_array(bytes(grbfile), &#34;LENFILENAME&#34;)),
        byref(idis),
        byref(ncells),
        byref(ndim1),
        byref(ndim2),
        byref(ndim3),
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(
        &#34;installed mf6 grid %r from grbfile=%r&#34;, gridname, grbfile.name
    )
    return {
        &#34;idis&#34;: idis.value,
        &#34;ncells&#34;: ncells.value,
        &#34;ndim1&#34;: ndim1.value,
        &#34;ndim2&#34;: ndim2.value,
        &#34;ndim3&#34;: ndim3.value,
    }</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.install_structured_grid"><code class="name flex">
<span>def <span class="ident">install_structured_grid</span></span>(<span>self, gridname:str, ncol:int, nrow:int, nlay:int, icorner:int, e0:float, n0:float, rotation:float, delr:float|npt.ArrayLike, delc:float|npt.ArrayLike) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Install specifications for a structured grid.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gridname</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique non-blank grid name.</dd>
<dt><strong><code>ncol</code></strong>, <strong><code>nrow</code></strong>, <strong><code>nlay</code></strong> :&ensp;<code>int</code></dt>
<dd>Grid dimensions.</dd>
<dt><strong><code>icorner</code></strong> :&ensp;<code>int</code></dt>
<dd>Reference corner, use 1 for top left and 2 for bottom left.</dd>
<dt><strong><code>e0</code></strong>, <strong><code>n0</code></strong> :&ensp;<code>float</code></dt>
<dd>Reference offsets.</dd>
<dt><strong><code>rotation</code></strong> :&ensp;<code>float</code></dt>
<dd>Grid rotation, counter-clockwise degrees.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def install_structured_grid(
    self,
    gridname: str,
    ncol: int,
    nrow: int,
    nlay: int,
    icorner: int,
    e0: float,
    n0: float,
    rotation: float,
    delr: float | npt.ArrayLike,
    delc: float | npt.ArrayLike,
) -&gt; None:
    &#34;&#34;&#34;Install specifications for a structured grid.

    Parameters
    ----------
    gridname : str
        Unique non-blank grid name.
    ncol, nrow, nlay : int
        Grid dimensions.
    icorner : int
        Reference corner, use 1 for top left and 2 for bottom left.
    e0, n0 : float
        Reference offsets.
    rotation : float
        Grid rotation, counter-clockwise degrees.
    &#34;&#34;&#34;
    validate_scalar(&#34;ncol&#34;, ncol, gt=0)
    validate_scalar(&#34;nrow&#34;, nrow, gt=0)
    validate_scalar(&#34;nlay&#34;, nlay, gt=0)
    col = ManyArrays(float_any={&#34;delr&#34;: delr}, ar_len=ncol)
    row = ManyArrays(float_any={&#34;delc&#34;: delc}, ar_len=nrow)
    col.validate(&#34;delr&#34;, gt=0.0)
    row.validate(&#34;delc&#34;, gt=0.0)
    validate_scalar(&#34;icorner&#34;, icorner, isin=[1, 2])
    res = self.pestutils.install_structured_grid(
        byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
        byref(c_int(ncol)),
        byref(c_int(nrow)),
        byref(c_int(nlay)),
        byref(c_int(icorner)),
        byref(c_double(e0)),
        byref(c_double(n0)),
        byref(c_double(rotation)),
        col.delr,
        row.delc,
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;installed structured grid %r from specs&#34;, gridname)</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.interp_from_mf6_depvar_file"><code class="name flex">
<span>def <span class="ident">interp_from_mf6_depvar_file</span></span>(<span>self, depvarfile:str|PathLike, factorfile:str|PathLike, factorfiletype:int|str|enum.FactorFileType, ntime:int, vartype:str, interpthresh:float, reapportion:int|bool, nointerpval:float, npts:int) >dict</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolate points using previously-calculated interpolation factors.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>depvarfile</code></strong> :&ensp;<code>str</code> or <code>PathLike</code></dt>
<dd>Name of binary file to read.</dd>
<dt><strong><code>factorfile</code></strong> :&ensp;<code>str</code> or <code>PathLike</code></dt>
<dd>File containing spatial interpolation factors, written by
:meth:<code>calc_mf6_interp_factors</code>.</dd>
<dt><strong><code>factorfiletype</code></strong> :&ensp;<code>int, str</code> or <code>enum.FactorFileType</code></dt>
<dd>Use 0 for binary; 1 for text.</dd>
<dt><strong><code>ntime</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of output times.</dd>
<dt><strong><code>vartype</code></strong> :&ensp;<code>str</code></dt>
<dd>Only read arrays of this type.</dd>
<dt><strong><code>interpthresh</code></strong> :&ensp;<code>float</code></dt>
<dd>Absolute threshold for dry or inactive.</dd>
<dt><strong><code>reapportion</code></strong> :&ensp;<code>int</code> or <code>bool</code></dt>
<dd>Use 0 for no (False); 1 for yes (True).</dd>
<dt><strong><code>nointerpval</code></strong> :&ensp;<code>float</code></dt>
<dd>Value to use where interpolation is not possible.</dd>
<dt><strong><code>npts</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of points for interpolation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>nproctime</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of processed simulation times.</dd>
<dt><strong><code>simtime</code></strong> :&ensp;<code>npt.NDArray[np.float64]</code></dt>
<dd>Simulation times, with shape (ntime,).</dd>
<dt><strong><code>simstate</code></strong> :&ensp;<code>npt.NDArray[np.float64]</code></dt>
<dd>Interpolated system states, with shape (ntime, npts).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interp_from_mf6_depvar_file(
    self,
    depvarfile: str | PathLike,
    factorfile: str | PathLike,
    factorfiletype: int | str | enum.FactorFileType,
    ntime: int,
    vartype: str,
    interpthresh: float,
    reapportion: int | bool,
    nointerpval: float,
    npts: int,
) -&gt; dict:
    &#34;&#34;&#34;
    Interpolate points using previously-calculated interpolation factors.

    Parameters
    ----------
    depvarfile : str or PathLike
        Name of binary file to read.
    factorfile : str or PathLike
        File containing spatial interpolation factors, written by
        :meth:`calc_mf6_interp_factors`.
    factorfiletype : int, str or enum.FactorFileType
        Use 0 for binary; 1 for text.
    ntime : int
        Number of output times.
    vartype : str
        Only read arrays of this type.
    interpthresh : float
        Absolute threshold for dry or inactive.
    reapportion : int or bool
        Use 0 for no (False); 1 for yes (True).
    nointerpval : float
        Value to use where interpolation is not possible.
    npts : int
        Number of points for interpolation.

    Returns
    -------
    nproctime : int
        Number of processed simulation times.
    simtime : npt.NDArray[np.float64]
        Simulation times, with shape (ntime,).
    simstate : npt.NDArray[np.float64]
        Interpolated system states, with shape (ntime, npts).
    &#34;&#34;&#34;
    depvarfile = Path(depvarfile)
    if not depvarfile.is_file():
        raise FileNotFoundError(f&#34;could not find depvarfile {depvarfile}&#34;)
    factorfile = Path(factorfile)
    if not factorfile.is_file():
        raise FileNotFoundError(f&#34;could not find factorfile {factorfile}&#34;)
    if isinstance(factorfiletype, str):
        factorfiletype = enum.FactorFileType.get_value(factorfiletype)
    simtime = np.zeros(ntime, np.float64, order=&#34;F&#34;)
    simstate = np.zeros((ntime, npts), np.float64, order=&#34;F&#34;)
    nproctime = c_int()
    res = self.pestutils.interp_from_mf6_depvar_file(
        byref(self.create_char_array(bytes(depvarfile), &#34;LENFILENAME&#34;)),
        byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
        byref(c_int(factorfiletype)),
        byref(c_int(ntime)),
        byref(self.create_char_array(vartype, &#34;LENVARTYPE&#34;)),
        byref(c_double(interpthresh)),
        byref(c_int(reapportion)),
        byref(c_double(nointerpval)),
        byref(c_int(npts)),
        byref(nproctime),
        simtime,
        simstate,
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(
        &#34;interpolated %d points from mf6 depvar file %r&#34;, npts, depvarfile.name
    )
    return {
        &#34;nproctime&#34;: nproctime.value,
        &#34;simtime&#34;: simtime.copy(&#34;A&#34;),
        &#34;simstate&#34;: simstate.copy(&#34;A&#34;),
    }</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.interp_from_structured_grid"><code class="name flex">
<span>def <span class="ident">interp_from_structured_grid</span></span>(<span>self, gridname:str, depvarfile:str|PathLike, isim:int, iprec:int|str|enum.Prec, ntime:int, vartype:str, interpthresh:float, nointerpval:float, ecoord:npt.ArrayLike, ncoord:npt.ArrayLike, layer:int|npt.ArrayLike) >dict</span>
</code></dt>
<dd>
<div class="desc"><p>Spatial interpolate points from a structured grid.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gridname</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of installed structured grid.</dd>
<dt><strong><code>depvarfile</code></strong> :&ensp;<code>str</code> or <code>PathLike</code></dt>
<dd>Name of binary file to read.</dd>
<dt><strong><code>isim</code></strong> :&ensp;<code>int</code></dt>
<dd>Specify -1 for MT3D; 1 for MODFLOW.</dd>
<dt><strong><code>iprec</code></strong> :&ensp;<code>int, str</code> or <code>enum.Prec</code></dt>
<dd>Specify 1 or "single", 2 or "double", or use enum.Prec.</dd>
<dt><strong><code>ntime</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of output times.</dd>
<dt><strong><code>vartype</code></strong> :&ensp;<code>str</code></dt>
<dd>Only read arrays of this type.</dd>
<dt><strong><code>interpthresh</code></strong> :&ensp;<code>float</code></dt>
<dd>Absolute threshold for dry or inactive.</dd>
<dt><strong><code>nointerpval</code></strong> :&ensp;<code>float</code></dt>
<dd>Value to use where interpolation is not possible.</dd>
<dt><strong><code>ecoord</code></strong>, <strong><code>ncoord</code></strong> :&ensp;<code>array_like</code></dt>
<dd>X/Y or Easting/Northing coordinates for points with shape (npts,).</dd>
<dt><strong><code>layer</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Layers of points with shape (npts,).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>nproctime</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of processed simulation times.</dd>
<dt><strong><code>simtime</code></strong> :&ensp;<code>npt.NDArray[np.float64]</code></dt>
<dd>Simulation times, with shape (ntime,).</dd>
<dt><strong><code>simstate</code></strong> :&ensp;<code>npt.NDArray[np.float64]</code></dt>
<dd>Interpolated system states, with shape (ntime, npts).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interp_from_structured_grid(
    self,
    gridname: str,
    depvarfile: str | PathLike,
    isim: int,
    iprec: int | str | enum.Prec,
    ntime: int,
    vartype: str,
    interpthresh: float,
    nointerpval: float,
    # npts: int,  # determined from layer.shape[0]
    ecoord: npt.ArrayLike,
    ncoord: npt.ArrayLike,
    layer: int | npt.ArrayLike,
) -&gt; dict:
    &#34;&#34;&#34;Spatial interpolate points from a structured grid.

    Parameters
    ----------
    gridname : str
        Name of installed structured grid.
    depvarfile : str or PathLike
        Name of binary file to read.
    isim : int
        Specify -1 for MT3D; 1 for MODFLOW.
    iprec : int, str or enum.Prec
        Specify 1 or &#34;single&#34;, 2 or &#34;double&#34;, or use enum.Prec.
    ntime : int
        Number of output times.
    vartype : str
        Only read arrays of this type.
    interpthresh : float
        Absolute threshold for dry or inactive.
    nointerpval : float
        Value to use where interpolation is not possible.
    ecoord, ncoord : array_like
        X/Y or Easting/Northing coordinates for points with shape (npts,).
    layer : int or array_like
        Layers of points with shape (npts,).

    Returns
    -------
    nproctime : int
        Number of processed simulation times.
    simtime : npt.NDArray[np.float64]
        Simulation times, with shape (ntime,).
    simstate : npt.NDArray[np.float64]
        Interpolated system states, with shape (ntime, npts).
    &#34;&#34;&#34;
    depvarfile = Path(depvarfile)
    if not depvarfile.is_file():
        raise FileNotFoundError(f&#34;could not find depvarfile {depvarfile}&#34;)
    if isinstance(iprec, str):
        iprec = enum.Prec.get_value(iprec)
    pta = ManyArrays({&#34;ecoord&#34;: ecoord, &#34;ncoord&#34;: ncoord}, int_any={&#34;layer&#34;: layer})
    npts = len(pta)
    simtime = np.zeros(ntime, np.float64, order=&#34;F&#34;)
    simstate = np.zeros((ntime, npts), np.float64, order=&#34;F&#34;)
    nproctime = c_int()
    res = self.pestutils.interp_from_structured_grid(
        byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;)),
        byref(self.create_char_array(bytes(depvarfile), &#34;LENFILENAME&#34;)),
        byref(c_int(isim)),
        byref(c_int(iprec)),
        byref(c_int(ntime)),
        byref(self.create_char_array(vartype, &#34;LENVARTYPE&#34;)),
        byref(c_double(interpthresh)),
        byref(c_double(nointerpval)),
        byref(c_int(npts)),
        pta.ecoord,
        pta.ncoord,
        pta.layer,
        byref(nproctime),
        simtime,
        simstate,
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(
        &#34;interpolated %d points from structured grid %r&#34;, npts, gridname
    )
    return {
        &#34;nproctime&#34;: nproctime.value,
        &#34;simtime&#34;: simtime.copy(&#34;A&#34;),
        &#34;simstate&#34;: simstate.copy(&#34;A&#34;),
    }</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.interp_to_obstime"><code class="name flex">
<span>def <span class="ident">interp_to_obstime</span></span>(<span>self, nproctime:int, simtime:npt.ArrayLike, simval:npt.ArrayLike, interpthresh:float, how_extrap:str, time_extrap:float, nointerpval:float, obspoint:npt.ArrayLike, obstime:npt.ArrayLike) >numpy.ndarray[typing.Any,numpy.dtype[numpy.float64]]</span>
</code></dt>
<dd>
<div class="desc"><p>Temporal interpolation for simulation times to observed times.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nproctime</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of times featured in simtime and simval.</dd>
<dt><strong><code>simtime</code></strong> :&ensp;<code>array_like</code></dt>
<dd>1D array of simulation times with shape (nsimtime,).</dd>
<dt><strong><code>simval</code></strong> :&ensp;<code>array_like</code></dt>
<dd>2D array of simulated values with shape (nsimtime, npts).</dd>
<dt><strong><code>interpthresh</code></strong> :&ensp;<code>float</code></dt>
<dd>Values equal or above this in simval have no meaning.</dd>
<dt><strong><code>how_extrap</code></strong> :&ensp;<code>str</code></dt>
<dd>Method, where 'L'=linear; 'C'=constant.</dd>
<dt><strong><code>time_extrap</code></strong> :&ensp;<code>float</code></dt>
<dd>Permitted extrapolation time.</dd>
<dt><strong><code>nointerpval</code></strong> :&ensp;<code>float</code></dt>
<dd>Value to use where interpolation is not possible.</dd>
<dt><strong><code>obspoint</code></strong> :&ensp;<code>array_like</code></dt>
<dd>1D integer array of indices of observation points,
which start at 0 and -1 means no index. Shape is (nobs,).</dd>
<dt><strong><code>obstime</code></strong> :&ensp;<code>array_like</code></dt>
<dd>1D array of observation times with shape (nobs,).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Time-interpolated simulation values with shape (nobs,).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interp_to_obstime(
    self,
    # nsimtime: int,  # determined from simval.shape[0]
    nproctime: int,
    # npts: int,  # determined from simval.shape[1]
    simtime: npt.ArrayLike,
    simval: npt.ArrayLike,
    interpthresh: float,
    how_extrap: str,
    time_extrap: float,
    nointerpval: float,
    # nobs: int,  # determined from obspoint.shape[0]
    obspoint: npt.ArrayLike,
    obstime: npt.ArrayLike,
) -&gt; npt.NDArray[np.float64]:
    &#34;&#34;&#34;Temporal interpolation for simulation times to observed times.

    Parameters
    ----------
    nproctime : int
        Number of times featured in simtime and simval.
    simtime : array_like
        1D array of simulation times with shape (nsimtime,).
    simval : array_like
        2D array of simulated values with shape (nsimtime, npts).
    interpthresh : float
        Values equal or above this in simval have no meaning.
    how_extrap : str
        Method, where &#39;L&#39;=linear; &#39;C&#39;=constant.
    time_extrap : float
        Permitted extrapolation time.
    nointerpval : float
        Value to use where interpolation is not possible.
    obspoint : array_like
        1D integer array of indices of observation points,
        which start at 0 and -1 means no index. Shape is (nobs,).
    obstime : array_like
        1D array of observation times with shape (nobs,).

    Returns
    -------
    np.ndarray
        Time-interpolated simulation values with shape (nobs,).
    &#34;&#34;&#34;
    simtime = np.array(simtime, dtype=np.float64, order=&#34;F&#34;, copy=False)
    simval = np.array(simval, dtype=np.float64, order=&#34;F&#34;, copy=False)
    obspoint = np.array(obspoint, order=&#34;F&#34;, copy=False)
    obstime = np.array(obstime, dtype=np.float64, order=&#34;F&#34;, copy=False)
    if simtime.ndim != 1:
        raise ValueError(&#34;expected &#39;simtime&#39; to have ndim=1&#34;)
    elif simval.ndim != 2:
        raise ValueError(&#34;expected &#39;simval&#39; to have ndim=2&#34;)
    elif obspoint.ndim != 1:
        raise ValueError(&#34;expected &#39;obspoint&#39; to have ndim=1&#34;)
    elif obstime.ndim != 1:
        raise ValueError(&#34;expected &#39;obstime&#39; to have ndim=1&#34;)
    elif not np.issubdtype(obspoint.dtype, np.integer):
        raise ValueError(
            f&#34;expected &#39;obspoint&#39; to be integer type; found {obspoint.dtype}&#34;
        )
    nsimtime, npts = simval.shape
    nobs = len(obspoint)
    obssimval = np.zeros(nobs, np.float64, order=&#34;F&#34;)
    res = self.pestutils.interp_to_obstime(
        byref(c_int(nsimtime)),
        byref(c_int(nproctime)),
        byref(c_int(npts)),
        simtime,
        simval,
        byref(c_double(interpthresh)),
        byref(c_char(how_extrap.encode())),
        byref(c_double(time_extrap)),
        byref(c_double(nointerpval)),
        byref(c_int(nobs)),
        obspoint.astype(np.int32, copy=False),
        obstime,
        obssimval,
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;interpolated %d time points to %d observations&#34;, npts, nobs)
    return obssimval.copy(&#34;A&#34;)</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.interpolate_blend_using_file"><code class="name flex">
<span>def <span class="ident">interpolate_blend_using_file</span></span>(<span>self, factorfile:str|PathLike, factorfiletype:int|str|enum.FactorFileType, transtype:int|str|enum.TransType, lt_target:str|bool, gt_target:str|bool, sourceval:npt.ArrayLike, targval:npt.ArrayLike) >dict</span>
</code></dt>
<dd>
<div class="desc"><p>Apply interpolation factors calculated by :meth:<code>calc_structural_overlay_factors</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>factorfile</code></strong> :&ensp;<code>str</code> or <code>PathLike</code></dt>
<dd>File for kriging factors.</dd>
<dt><strong><code>factorfiletype</code></strong> :&ensp;<code>int, str</code> or <code>enum.FactorFileType</code></dt>
<dd>Factor file type, where 0:binary, 1:text.</dd>
<dt><strong><code>transtype</code></strong> :&ensp;<code>int, str, enum.TransType</code></dt>
<dd>Tranformation type, where 0 is none and 1 is log.</dd>
<dt><strong><code>lt_target</code></strong>, <strong><code>gt_target</code></strong> :&ensp;<code>str</code> or <code>bool</code></dt>
<dd>Whether to undercut or exceed target, use "Y"/"N" or bool.</dd>
<dt><strong><code>sourceval</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Values at sources, 1D array with shape (npts,).</dd>
<dt><strong><code>targval</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Values at targets, 1D array with shape (mpts,).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>targval</code></strong> :&ensp;<code>npt.NDArray[np.float64]</code></dt>
<dd>Values calculated for targets.</dd>
<dt><strong><code>icount_interp</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of interpolation pts.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_blend_using_file(
    self,
    factorfile: str | PathLike,
    factorfiletype: int | str | enum.FactorFileType,
    # npts: int,  # determined from sourceval.shape[0]
    # mpts: int,  # determined from targval.shape[0]
    transtype: int | str | enum.TransType,
    lt_target: str | bool,
    gt_target: str | bool,
    sourceval: npt.ArrayLike,
    targval: npt.ArrayLike,
) -&gt; dict:
    &#34;&#34;&#34;
    Apply interpolation factors calculated by :meth:`calc_structural_overlay_factors`.

    Parameters
    ----------
    factorfile : str or PathLike
        File for kriging factors.
    factorfiletype : int, str or enum.FactorFileType
        Factor file type, where 0:binary, 1:text.
    transtype : int, str, enum.TransType
        Tranformation type, where 0 is none and 1 is log.
    lt_target, gt_target : str or bool
        Whether to undercut or exceed target, use &#34;Y&#34;/&#34;N&#34; or bool.
    sourceval : array_like
        Values at sources, 1D array with shape (npts,).
    targval : array_like
        Values at targets, 1D array with shape (mpts,).

    Returns
    -------
    targval : npt.NDArray[np.float64]
        Values calculated for targets.
    icount_interp : int
        Number of interpolation pts.
    &#34;&#34;&#34;
    factorfile = Path(factorfile)
    if not factorfile.is_file():
        raise FileNotFoundError(f&#34;could not find factorfile {factorfile}&#34;)
    if isinstance(factorfiletype, str):
        factorfiletype = enum.FactorFileType.get_value(factorfiletype)
    if isinstance(transtype, str):
        transtype = enum.TransType.get_value(transtype)
    if isinstance(lt_target, bool):
        lt_target = &#34;y&#34; if lt_target else &#34;n&#34;
    if isinstance(gt_target, bool):
        gt_target = &#34;y&#34; if gt_target else &#34;n&#34;
    npta = ManyArrays({&#34;sourceval&#34;: sourceval})
    npts = len(npta)
    mpta = ManyArrays({&#34;targval&#34;: targval})
    mpts = len(mpta)
    icount_interp = c_int()
    res = self.pestutils.interpolate_blend_using_file(
        byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
        byref(c_int(factorfiletype)),
        byref(c_int(npts)),
        byref(c_int(mpts)),
        byref(c_int(transtype)),
        byref(c_char(lt_target.encode())),
        byref(c_char(gt_target.encode())),
        npta.sourceval,
        mpta.targval,
        byref(icount_interp),
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;applied interpolation factors from %r&#34;, factorfile.name)
    return {
        &#34;targval&#34;: mpts.targval.copy(&#34;A&#34;),
        &#34;icount_interp&#34;: icount_interp.value,
    }</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.ipd_interpolate_2d"><code class="name flex">
<span>def <span class="ident">ipd_interpolate_2d</span></span>(<span>self, ecs:npt.ArrayLike, ncs:npt.ArrayLike, zns:int|npt.ArrayLike, sourceval:npt.ArrayLike, ect:npt.ArrayLike, nct:npt.ArrayLike, znt:int|npt.ArrayLike, transtype:int|str|enum.TransType, anis:float|npt.ArrayLike, bearing:float|npt.ArrayLike, invpow:float|npt.ArrayLike) >numpy.ndarray[typing.Any,numpy.dtype[numpy.float64]]</span>
</code></dt>
<dd>
<div class="desc"><p>Undertake 2D inverse-power-of-distance spatial interpolation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ecs</code></strong>, <strong><code>ncs</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Source point coordinates, each 1D array with shape (npts,).</dd>
<dt><strong><code>zns</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Source point zones, integer or 1D array with shape (npts,).</dd>
<dt><strong><code>sourceval</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Source values, 1D array with shape (npts,).</dd>
<dt><strong><code>ect</code></strong>, <strong><code>nct</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Target point coordinates, each 1D array with shape (mpts,).</dd>
<dt><strong><code>znt</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Target point zones, integer or 1D array with shape (mpts,).</dd>
<dt><strong><code>transtype</code></strong> :&ensp;<code>int, str, enum.TransType</code></dt>
<dd>Tranformation type, where 0 is none and 1 is log.</dd>
<dt><strong><code>anis</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Local anisotropy, float or 1D array with shape (mpts,).</dd>
<dt><strong><code>bearing</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Local anisotropy bearing, float or 1D array with shape (mpts,).</dd>
<dt><strong><code>invpow</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Local inverse power of distance, float or 1D array with shape (mpts,).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>npt.NDArray[np.float64]</code></dt>
<dd>Values calculated for targets.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ipd_interpolate_2d(
    self,
    # npts: int,  # determined from ecs.shape[0]
    ecs: npt.ArrayLike,
    ncs: npt.ArrayLike,
    zns: int | npt.ArrayLike,
    sourceval: npt.ArrayLike,
    # mpts: int,  # determined from ect.shape[0]
    ect: npt.ArrayLike,
    nct: npt.ArrayLike,
    znt: int | npt.ArrayLike,
    transtype: int | str | enum.TransType,
    anis: float | npt.ArrayLike,
    bearing: float | npt.ArrayLike,
    invpow: float | npt.ArrayLike,
) -&gt; npt.NDArray[np.float64]:
    &#34;&#34;&#34;Undertake 2D inverse-power-of-distance spatial interpolation.

    Parameters
    ----------
    ecs, ncs : array_like
        Source point coordinates, each 1D array with shape (npts,).
    zns : int or array_like
        Source point zones, integer or 1D array with shape (npts,).
    sourceval : array_like
        Source values, 1D array with shape (npts,).
    ect, nct : array_like
        Target point coordinates, each 1D array with shape (mpts,).
    znt : int or array_like
        Target point zones, integer or 1D array with shape (mpts,).
    transtype : int, str, enum.TransType
        Tranformation type, where 0 is none and 1 is log.
    anis : float or array_like
        Local anisotropy, float or 1D array with shape (mpts,).
    bearing : float or array_like
        Local anisotropy bearing, float or 1D array with shape (mpts,).
    invpow : float or array_like
        Local inverse power of distance, float or 1D array with shape (mpts,).

    Returns
    -------
    npt.NDArray[np.float64]
        Values calculated for targets.
    &#34;&#34;&#34;
    npta = ManyArrays(
        {&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs, &#34;sourceval&#34;: sourceval}, int_any={&#34;zns&#34;: zns}
    )
    npts = len(npta)
    mpta = ManyArrays(
        {&#34;ect&#34;: ect, &#34;nct&#34;: nct},
        {&#34;anis&#34;: anis, &#34;bearing&#34;: bearing, &#34;invpow&#34;: invpow},
        {&#34;znt&#34;: znt},
    )
    mpts = len(mpta)
    if isinstance(transtype, str):
        transtype = enum.TransType.get_value(transtype)
    targval = np.zeros(mpts, np.float64, order=&#34;F&#34;)
    res = self.pestutils.ipd_interpolate_2d(
        byref(c_int(npts)),
        npta.ecs,
        npta.ncs,
        npta.zns,
        npta.sourceval,
        byref(c_int(mpts)),
        mpta.ect,
        mpta.nct,
        mpta.znt,
        targval,
        byref(c_int(transtype)),
        mpta.anis,
        mpta.bearing,
        mpta.invpow,
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;undertook 2D inverse-power-of-distance spatial interpolation&#34;)
    return targval.copy(&#34;A&#34;)</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.ipd_interpolate_3d"><code class="name flex">
<span>def <span class="ident">ipd_interpolate_3d</span></span>(<span>self, ecs:npt.ArrayLike, ncs:npt.ArrayLike, zcs:npt.ArrayLike, zns:int|npt.ArrayLike, sourceval:npt.ArrayLike, ect:npt.ArrayLike, nct:npt.ArrayLike, zct:npt.ArrayLike, znt:int|npt.ArrayLike, transtype:int|str|enum.TransType, ahmax:float|npt.ArrayLike, ahmin:float|npt.ArrayLike, avert:float|npt.ArrayLike, bearing:float|npt.ArrayLike, dip:float|npt.ArrayLike, rake:float|npt.ArrayLike, invpow:float|npt.ArrayLike) >numpy.ndarray[typing.Any,numpy.dtype[numpy.float64]]</span>
</code></dt>
<dd>
<div class="desc"><p>Undertake 3D inverse-power-of-distance spatial interpolation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ecs</code></strong>, <strong><code>ncs</code></strong>, <strong><code>zcs</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Source point coordinates, each 1D array with shape (npts,).</dd>
<dt><strong><code>zns</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Source point zones, integer or 1D array with shape (npts,).</dd>
<dt><strong><code>sourceval</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Source values, 1D array with shape (npts,).</dd>
<dt><strong><code>ect</code></strong>, <strong><code>nct</code></strong>, <strong><code>zct</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Target point coordinates, each 1D array with shape (mpts,).</dd>
<dt><strong><code>znt</code></strong> :&ensp;<code>int</code> or <code>array_like</code></dt>
<dd>Target point zones, integer or 1D array with shape (mpts,).</dd>
<dt><strong><code>transtype</code></strong> :&ensp;<code>int, str, enum.TransType</code></dt>
<dd>Tranformation type, where 0 is none and 1 is log.</dd>
<dt><strong><code>ahmax</code></strong>, <strong><code>ahmin</code></strong>, <strong><code>avert</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Relative correlation lengths, float or 1D array with shape (mpts,).</dd>
<dt><strong><code>bearing</code></strong>, <strong><code>dip</code></strong>, <strong><code>rake</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Correlation directions, float or 1D array with shape (mpts,).</dd>
<dt><strong><code>invpow</code></strong> :&ensp;<code>float</code> or <code>array_like</code></dt>
<dd>Local inverse power of distance, float or 1D array with shape (mpts,).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>npt.NDArray[np.float64]</code></dt>
<dd>Values calculated for targets.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ipd_interpolate_3d(
    self,
    # npts: int,  # determined from ecs.shape[0]
    ecs: npt.ArrayLike,
    ncs: npt.ArrayLike,
    zcs: npt.ArrayLike,
    zns: int | npt.ArrayLike,
    sourceval: npt.ArrayLike,
    # mpts: int,  # determined from ect.shape[0]
    ect: npt.ArrayLike,
    nct: npt.ArrayLike,
    zct: npt.ArrayLike,
    znt: int | npt.ArrayLike,
    transtype: int | str | enum.TransType,
    ahmax: float | npt.ArrayLike,
    ahmin: float | npt.ArrayLike,
    avert: float | npt.ArrayLike,
    bearing: float | npt.ArrayLike,
    dip: float | npt.ArrayLike,
    rake: float | npt.ArrayLike,
    invpow: float | npt.ArrayLike,
) -&gt; npt.NDArray[np.float64]:
    &#34;&#34;&#34;Undertake 3D inverse-power-of-distance spatial interpolation.

    Parameters
    ----------
    ecs, ncs, zcs : array_like
        Source point coordinates, each 1D array with shape (npts,).
    zns : int or array_like
        Source point zones, integer or 1D array with shape (npts,).
    sourceval : array_like
        Source values, 1D array with shape (npts,).
    ect, nct, zct : array_like
        Target point coordinates, each 1D array with shape (mpts,).
    znt : int or array_like
        Target point zones, integer or 1D array with shape (mpts,).
    transtype : int, str, enum.TransType
        Tranformation type, where 0 is none and 1 is log.
    ahmax, ahmin, avert : float or array_like
        Relative correlation lengths, float or 1D array with shape (mpts,).
    bearing, dip, rake : float or array_like
        Correlation directions, float or 1D array with shape (mpts,).
    invpow : float or array_like
        Local inverse power of distance, float or 1D array with shape (mpts,).

    Returns
    -------
    npt.NDArray[np.float64]
        Values calculated for targets.
    &#34;&#34;&#34;
    npta = ManyArrays(
        {&#34;ecs&#34;: ecs, &#34;ncs&#34;: ncs, &#34;zcs&#34;: zcs, &#34;sourceval&#34;: sourceval},
        int_any={&#34;zns&#34;: zns},
    )
    npts = len(npta)
    mpta = ManyArrays(
        {&#34;ect&#34;: ect, &#34;nct&#34;: nct, &#34;zct&#34;: zct},
        {
            &#34;ahmax&#34;: ahmax,
            &#34;ahmin&#34;: ahmin,
            &#34;avert&#34;: avert,
            &#34;bearing&#34;: bearing,
            &#34;dip&#34;: dip,
            &#34;rake&#34;: rake,
            &#34;invpow&#34;: invpow,
        },
        {&#34;znt&#34;: znt},
    )
    mpts = len(mpta)
    if isinstance(transtype, str):
        transtype = enum.TransType.get_value(transtype)
    targval = np.zeros(mpts, np.float64, order=&#34;F&#34;)
    res = self.pestutils.ipd_interpolate_3d(
        byref(c_int(npts)),
        npta.ecs,
        npta.ncs,
        npta.zcs,
        npta.zns,
        npta.sourceval,
        byref(c_int(mpts)),
        mpta.ect,
        mpta.nct,
        mpta.zct,
        mpta.znt,
        targval,
        byref(c_int(transtype)),
        mpta.ahmax,
        mpta.ahmin,
        mpta.avert,
        mpta.bearing,
        mpta.dip,
        mpta.rake,
        mpta.invpow,
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;undertook 3D inverse-power-of-distance spatial interpolation&#34;)
    return targval.copy(&#34;A&#34;)</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.krige_using_file"><code class="name flex">
<span>def <span class="ident">krige_using_file</span></span>(<span>self, factorfile:str|PathLike, factorfiletype:int|str|enum.FactorFileType, mpts:int, krigtype:int|str|enum.KrigType, transtype:int|str|enum.TransType, sourceval:npt.ArrayLike, meanval:float|npt.ArrayLike|None, nointerpval:float) >dict</span>
</code></dt>
<dd>
<div class="desc"><p>Apply interpolation factors calculated by other functions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>factorfile</code></strong> :&ensp;<code>str</code> or <code>PathLike</code></dt>
<dd>Input file with kriging factors.</dd>
<dt><strong><code>factorfiletype</code></strong> :&ensp;<code>int, str</code> or <code>enum.FactorFileType</code></dt>
<dd>Factor file type, where 0:binary, 1:text.</dd>
<dt><strong><code>mpts</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of target points, used to compare with value in factor file.</dd>
<dt><strong><code>krigtype</code></strong> :&ensp;<code>int, str,</code> or <code>enum.KrigType,</code></dt>
<dd>Kriging type, where 0:simple, 1:ordinary.</dd>
<dt><strong><code>transtype</code></strong> :&ensp;<code>int, str, enum.TransType</code></dt>
<dd>Tranformation type, where 0 is none and 1 is log.</dd>
<dt><strong><code>sourceval</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Values at sources, 1D array with shape (npts,).</dd>
<dt><strong><code>meanval</code></strong> :&ensp;<code>float, array_like</code>, optional</dt>
<dd>Mean values are required if simple kriging, described as a float
or 1D array with shape (mpts,).</dd>
<dt><strong><code>nointerpval</code></strong> :&ensp;<code>float</code></dt>
<dd>Value to use where interpolation is not possible.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>targval</code></strong> :&ensp;<code>npt.NDArray[np.float64]</code></dt>
<dd>Values calculated for targets.</dd>
<dt><strong><code>icount_interp</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of interpolation pts.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def krige_using_file(
    self,
    factorfile: str | PathLike,
    factorfiletype: int | str | enum.FactorFileType,
    # npts: int,  # determined from sourceval.shape[0]
    mpts: int,
    krigtype: int | str | enum.KrigType,
    transtype: int | str | enum.TransType,
    sourceval: npt.ArrayLike,
    meanval: float | npt.ArrayLike | None,
    nointerpval: float,
) -&gt; dict:
    &#34;&#34;&#34;
    Apply interpolation factors calculated by other functions.

    Parameters
    ----------
    factorfile : str or PathLike
        Input file with kriging factors.
    factorfiletype : int, str or enum.FactorFileType
        Factor file type, where 0:binary, 1:text.
    mpts : int
        Number of target points, used to compare with value in factor file.
    krigtype : int, str, or enum.KrigType,
        Kriging type, where 0:simple, 1:ordinary.
    transtype : int, str, enum.TransType
        Tranformation type, where 0 is none and 1 is log.
    sourceval : array_like
        Values at sources, 1D array with shape (npts,).
    meanval : float, array_like, optional
        Mean values are required if simple kriging, described as a float
        or 1D array with shape (mpts,).
    nointerpval : float
        Value to use where interpolation is not possible.

    Returns
    -------
    targval : npt.NDArray[np.float64]
        Values calculated for targets.
    icount_interp : int
        Number of interpolation pts.
    &#34;&#34;&#34;
    factorfile = Path(factorfile)
    if not factorfile.is_file():
        raise FileNotFoundError(f&#34;could not find factorfile {factorfile}&#34;)
    if isinstance(factorfiletype, str):
        factorfiletype = enum.FactorFileType.get_value(factorfiletype)
    if isinstance(krigtype, str):
        krigtype = enum.KrigType.get_value(krigtype)
    if isinstance(transtype, str):
        transtype = enum.TransType.get_value(transtype)
    npta = ManyArrays({&#34;sourceval&#34;: sourceval})
    npts = len(npta)
    if meanval is None:
        if krigtype == enum.KrigType.simple:
            self.logger.error(
                &#34;simple kriging requires &#39;meanval&#39;; assuming zero for now&#34;
            )
        meanval = 0.0
    mpta = ManyArrays(float_any={&#34;meanval&#34;: meanval}, ar_len=mpts)
    targval = np.full(mpts, nointerpval, dtype=np.float64, order=&#34;F&#34;)
    icount_interp = c_int()
    res = self.pestutils.krige_using_file(
        byref(self.create_char_array(bytes(factorfile), &#34;LENFILENAME&#34;)),
        byref(c_int(factorfiletype)),
        byref(c_int(npts)),
        byref(c_int(mpts)),
        byref(c_int(krigtype)),
        byref(c_int(transtype)),
        npta.sourceval,
        targval,
        byref(icount_interp),
        mpta.meanval,
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;kriged using factor file %r&#34;, factorfile.name)
    return {
        &#34;targval&#34;: targval.copy(&#34;A&#34;),
        &#34;icount_interp&#34;: icount_interp.value,
    }</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.retrieve_error_message"><code class="name flex">
<span>def <span class="ident">retrieve_error_message</span></span>(<span>self) >str</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve error message from library.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_error_message(self) -&gt; str:
    &#34;&#34;&#34;Retrieve error message from library.

    Returns
    -------
    str
    &#34;&#34;&#34;
    from .ctypes_declarations import get_char_array

    charray = get_char_array(self.pestutils, &#34;LENMESSAGE&#34;)()
    res = self.pestutils.retrieve_error_message(byref(charray))
    return charray[:res].rstrip(b&#34;\x00&#34;).decode()</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.uninstall_mf6_grid"><code class="name flex">
<span>def <span class="ident">uninstall_mf6_grid</span></span>(<span>self, gridname:str) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Uninstall MF6 grid set by :meth:<code>install_mf6_grid_from_file</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gridname</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique non-blank grid name.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uninstall_mf6_grid(self, gridname: str) -&gt; None:
    &#34;&#34;&#34;Uninstall MF6 grid set by :meth:`install_mf6_grid_from_file`.

    Parameters
    ----------
    gridname : str
        Unique non-blank grid name.
    &#34;&#34;&#34;
    res = self.pestutils.uninstall_mf6_grid(
        byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;))
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;uninstalled mf6 grid %r&#34;, gridname)</code></pre>
</details>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLib.uninstall_structured_grid"><code class="name flex">
<span>def <span class="ident">uninstall_structured_grid</span></span>(<span>self, gridname:str) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Uninstall structured grid set by :meth:<code>install_structured_grid</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gridname</code></strong> :&ensp;<code>str</code></dt>
<dd>Unique non-blank grid name.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uninstall_structured_grid(self, gridname: str) -&gt; None:
    &#34;&#34;&#34;Uninstall structured grid set by :meth:`install_structured_grid`.

    Parameters
    ----------
    gridname : str
        Unique non-blank grid name.
    &#34;&#34;&#34;
    res = self.pestutils.uninstall_structured_grid(
        byref(self.create_char_array(gridname, &#34;LENGRIDNAME&#34;))
    )
    if res != 0:
        raise PestUtilsLibError(self.retrieve_error_message())
    self.logger.info(&#34;uninstalled structured grid %r&#34;, gridname)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pypestutils.pestutilslib.PestUtilsLibError"><code class="flex name class">
<span>class <span class="ident">PestUtilsLibError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Exception from PestUtilsLib.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PestUtilsLibError(BaseException):
    &#34;&#34;&#34;Exception from PestUtilsLib.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pypestutils" href="index.html">pypestutils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pypestutils.pestutilslib.PestUtilsLib" href="#pypestutils.pestutilslib.PestUtilsLib">PestUtilsLib</a></code></h4>
<ul class="">
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.build_covar_matrix_2d" href="#pypestutils.pestutilslib.PestUtilsLib.build_covar_matrix_2d">build_covar_matrix_2d</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.build_covar_matrix_3d" href="#pypestutils.pestutilslib.PestUtilsLib.build_covar_matrix_3d">build_covar_matrix_3d</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.calc_kriging_factors_2d" href="#pypestutils.pestutilslib.PestUtilsLib.calc_kriging_factors_2d">calc_kriging_factors_2d</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.calc_kriging_factors_3d" href="#pypestutils.pestutilslib.PestUtilsLib.calc_kriging_factors_3d">calc_kriging_factors_3d</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.calc_kriging_factors_auto_2d" href="#pypestutils.pestutilslib.PestUtilsLib.calc_kriging_factors_auto_2d">calc_kriging_factors_auto_2d</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.calc_mf6_interp_factors" href="#pypestutils.pestutilslib.PestUtilsLib.calc_mf6_interp_factors">calc_mf6_interp_factors</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.calc_structural_overlay_factors" href="#pypestutils.pestutilslib.PestUtilsLib.calc_structural_overlay_factors">calc_structural_overlay_factors</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.create_char_array" href="#pypestutils.pestutilslib.PestUtilsLib.create_char_array">create_char_array</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.extract_flows_from_cbc_file" href="#pypestutils.pestutilslib.PestUtilsLib.extract_flows_from_cbc_file">extract_flows_from_cbc_file</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.fieldgen2d_sva" href="#pypestutils.pestutilslib.PestUtilsLib.fieldgen2d_sva">fieldgen2d_sva</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.fieldgen3d_sva" href="#pypestutils.pestutilslib.PestUtilsLib.fieldgen3d_sva">fieldgen3d_sva</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.free_all_memory" href="#pypestutils.pestutilslib.PestUtilsLib.free_all_memory">free_all_memory</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.get_cell_centres_mf6" href="#pypestutils.pestutilslib.PestUtilsLib.get_cell_centres_mf6">get_cell_centres_mf6</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.get_cell_centres_structured" href="#pypestutils.pestutilslib.PestUtilsLib.get_cell_centres_structured">get_cell_centres_structured</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.initialize_randgen" href="#pypestutils.pestutilslib.PestUtilsLib.initialize_randgen">initialize_randgen</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.inquire_modflow_binary_file_specs" href="#pypestutils.pestutilslib.PestUtilsLib.inquire_modflow_binary_file_specs">inquire_modflow_binary_file_specs</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.install_mf6_grid_from_file" href="#pypestutils.pestutilslib.PestUtilsLib.install_mf6_grid_from_file">install_mf6_grid_from_file</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.install_structured_grid" href="#pypestutils.pestutilslib.PestUtilsLib.install_structured_grid">install_structured_grid</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.interp_from_mf6_depvar_file" href="#pypestutils.pestutilslib.PestUtilsLib.interp_from_mf6_depvar_file">interp_from_mf6_depvar_file</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.interp_from_structured_grid" href="#pypestutils.pestutilslib.PestUtilsLib.interp_from_structured_grid">interp_from_structured_grid</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.interp_to_obstime" href="#pypestutils.pestutilslib.PestUtilsLib.interp_to_obstime">interp_to_obstime</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.interpolate_blend_using_file" href="#pypestutils.pestutilslib.PestUtilsLib.interpolate_blend_using_file">interpolate_blend_using_file</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.ipd_interpolate_2d" href="#pypestutils.pestutilslib.PestUtilsLib.ipd_interpolate_2d">ipd_interpolate_2d</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.ipd_interpolate_3d" href="#pypestutils.pestutilslib.PestUtilsLib.ipd_interpolate_3d">ipd_interpolate_3d</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.krige_using_file" href="#pypestutils.pestutilslib.PestUtilsLib.krige_using_file">krige_using_file</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.retrieve_error_message" href="#pypestutils.pestutilslib.PestUtilsLib.retrieve_error_message">retrieve_error_message</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.uninstall_mf6_grid" href="#pypestutils.pestutilslib.PestUtilsLib.uninstall_mf6_grid">uninstall_mf6_grid</a></code></li>
<li><code><a title="pypestutils.pestutilslib.PestUtilsLib.uninstall_structured_grid" href="#pypestutils.pestutilslib.PestUtilsLib.uninstall_structured_grid">uninstall_structured_grid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pypestutils.pestutilslib.PestUtilsLibError" href="#pypestutils.pestutilslib.PestUtilsLibError">PestUtilsLibError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>